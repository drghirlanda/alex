#!/usr/bin/pebl-language

define Start( par ) {

  # This will have to be changed when installing: 
  gAlexDir <- "Library/Materials/"

  # Have we been asked to run in a directory other than .?
  gWD <- Nth(par, 1)
  if( gWd != 0 ) {
    gWD <- gWD + "/"
    if( not IsDirectory( gWD ) ) {
      SignalFatalError("Command line argument "+gWD+" is not a folder")
    }
  } else {
    gWD <- ""
  }

  ReadParameters()

  # Determine whether to run in test mode or not:
  test <- Parameter("Test")
  if( test != "NA" and ToNumber(test) == 1 ) {
    test <- 1
  } else {
    test <- 0
  }
  
  ## Initialize basic display elements:
  fg <- Parameter( "ForegroundColor" )
  bg <- Parameter( "BackgroundColor" )
  gWindow <- MakeWindow( bg )
  gBackgroundColor <- MakeColor( bg )
  gColor <- MakeColor( fg )
  gFont <- MakeFont( Parameter("FontName")+".ttf", 0, 
    ToNumber(Parameter("FontSize")), gColor, gBackgroundColor, 1 )

  ## Read other Design files:
  ReadSubject()
  ReadPhases()     
  ReadStimuli()    

  if( not test ) {
    gSex <- GetEasyChoice( "Please select your sex", 
    	 ["Male", "Female"], ["M", "F"], gWindow )
    gAge <- GetEasyInput( "Please enter your age in years, "+
      "then press enter:", gWindow )
    gAge <- ToInteger( gAge )
    Message( "Press the spacebar to start the experiment", 0 )
    Wait( 2000 )
  } else {
    gSex <- "NA"
    gAge <- "NA"
  }

  ShowCursor( 0 )

  ## Print data file header. gDataFile has been opened by
  ## ReadSubject() to avoid race conditions with acquiring and
  ## releasing the lock to Subjects.csv). We first print whatever
  ## fields are defined in Subjects.csv (stored in gSubjectHeader),
  ## then fields for other data:
  loop( field, gSubjectHeader ) {
    FilePrint_( gDataFile, field + "," )
  } 
  FilePrint( gDataFile, "Sex,Age,Phase,Trial,Stimulus,RewardPr,Response,Responses,RTs,Rewards" )

  ## Run experimental phases. We loop through all elements of the
  ## Phase column in Phases.csv. Phase p is run with RunPhase( p ),
  ## and we keep track of the phases already run in the alreadyRun
  ## list. The reason is that each phase name appears multiple times
  ## in the Phase column when the phase features multiple
  ## stimuli. RunPhase() looks for all stimuli pertaining to a phase,
  ## so we have to call it only once per phase.
  alreadyRun <- []
  loop( p, Lookup("Phase",gPhaseHeader,gPhases)  ){
    if( not Sum( Match( alreadyRun, p ) ) ) {
      RunPhase( p )
      PushOnEnd( alreadyRun, p )
    }
  }

  FileClose( gDataFile )
  ShowCursor( 1 )
}

########################################################################
#                                                                      #
# Display and Undisplay are two utility functions that can show and    #
# hide multiple visual stimuli, and also start and pause the playback  #
# of audio stimuli.                                                    #
#                                                                      #
########################################################################

define Display( stimulus ) {
  # The 'stimulus' may actually be a compound, like "A+B", so we split
  # it into individual stimuli and then display each of them. We look
  # up the stimulus objects in the gStimuli list.
  n <- Length( gStimNames )
  loop( stimName, SplitString(stimulus, "+") ) {
    i <- Lookup( stimName, gStimNames, Sequence(1,n,1) )
    s <- Nth( gStimuli, i )
    if( IsAudioOut(s) ) {
      StartPlayback( s )
    } else {
      Show( s )
    }
  }
  Draw()
}

define Undisplay( stimulus ) {
  n <- Length( gStimNames )
  loop( stimName, SplitString(stimulus, "+") ) {
    i <- Lookup( stimName, gStimNames, Sequence(1,n,1) )
    s <- Nth( gStimuli, i )
    if( IsAudioOut(s) ) {
      PausePlayback( s )
    } else {
      Hide( s )
    }
  }
  Draw()
}

# Helper function to determine the duration of stimuli. 
define ResolveDuration( stimulus, role ) {
  s <- First( SplitString(stimulus,"+") )
  durations <- []
  loop( s, SplitString(stimulus,"+") ) {
    d <- Resolve( "Duration", LookupStimulus( s, "Duration" ) )
    if( d == "NA" ) { # We did not find a CS-specific duration
      d <- Parameter( role + "Duration")
    }
    d <- ToNumber( d ) # NA becomes 0
    PushOnEnd( durations, d )
  }
  ## If any duration is 0 (could not be determined), we have an error:
  if( Sum( Match( durations, 0 ) ) ) {
    Message( "Could not determine duration of " + stimulus, 1 )
  }
  ## The duration information is valid if all durations are equal
  d <- First( durations )
  loop( d2, Rest( durations ) ) {
    if( d != d2 ) {
      Message( "Some stimuli have different durations in "+stimulus, 1 )
    }
  } 
  return d
}

########################################################################
#                                                                      #
# This function coordinates the events within a single trial           #
#                                                                      #
########################################################################


define OneTrial( stimulus, rewardProb, uss, response ) {
  Draw()
  # Determine CS and US duration:
  csDuration <- ResolveDuration( stimulus, "CS" )
  usDuration <- ResolveDuration( uss, "US" )
  # Determine other parameters:
  maxResponses <- Parameter("MaxResponses")
  if( maxResponses == "NA" ) {
    maxResponses <- 1
  } else {
    maxResponses <- ToNumber( maxResponses )
  }
  csusInterval <- ToNumber( Parameter("CSUSInterval") )
  rtMin <- Parameter("ReactionTimeMin")
  if( rtMin == "NA" ) {
    rtMin <- 0
  } else {
    rtMin <- ToNumber( rtMin )
  }
  rtMax <- Parameter("ReactionTimeMax")
  if( rtMax == "NA" ) {
    rtMax <- csDuration
  } else {
    rtMax <- ToNumber( rtMax )
  }
  # Preprocess the response variable to handle the special "space" key
  # and the "*" specification for 'classical' trials:
  classical <- 0
  if( response == "space" ) {
    keyList <- [" "]
  } elseif( SubString(response,1,1) == "*" ) {
    classical <- 1
    keyList <- [ SubString(response,2,StringLength(response)-1) ]
  } else {
    keyList <- [response]
  }
  # We are ready to run the trial loop. The trial continues until
  # either time runs out or we reach the maximum number of (valid)
  # responses.
  times        <- []
  rewards      <- []
  timeLeft     <- ToNumber( csDuration )
  startTime    <- GetTime()
  Display( stimulus )
  while( Length(times)<maxResponses and timeLeft>1 ) {
    key <- WaitForListKeyPressWithTimeout( keyList, timeLeft, 1 )
    rt <- GetTime() - startTime
    timeLeft <- csDuration - rt
    # If we did not time out we have to process the response:
    if( timeLeft > 1 ) {
      PushOnEnd( times, rt )
      if( classical == 0 ) {
        # If response is invalid, reward is -1:
        if( rt<rtMin or rt>rtMax ) {
          PushOnEnd( rewards, -1 )
        # If responses is valid and rewarded, reward is 1:
        } elseif( Random() < rewardProb and classical == 0 ) {
          PushOnEnd( rewards, 1 )
          Wait( csusInterval )
	  Display( uss )
          Wait( usDuration )
	  Undisplay( uss )
        # If responses is valid but unrewarded, reward is 0:
        } else {
          PushOnEnd( rewards, 0 )
        }
      } else {
        PushOnEnd( rewards, 0 )
      }
    }
    # Update timeLeft again because US display may have used time
    timeLeft <- csDuration - GetTime() + startTime
  }
  Undisplay( stimulus )
  Draw()
  ## This happens at the end of a 'classical conditioning' trial. 
  if( classical == 1 and Random() < rewardProb) {
    PushOnEnd( rewards, 1 )
    PushOnEnd( times, ToNumber(csDuration) )
    Display( uss )
    Wait( usDuration )
    Undisplay( uss )
  }
  # Set times and responses to NA if no response recorded:
  if( not Length(times) ) {
    times <- "NA"
    rewards <- "NA"
  }
  return [times, rewards]
}

# Helper function to identify what enters a phase. 
define LookupPhase( phaseName, field ) {
  fields <- Lookup(field, gPhaseHeader, gPhases)
  if( not Length(fields) ) {
    result <- []
  } else {
    idx <- Match( Lookup("Phase", gPhaseHeader, gPhases), phaseName) 
    result <- Filter( fields, idx )
  }
  ## If we did not find anything in Phases, we try to look up a global
  ## parameter and repeat it as many times as there are stimuli in the
  ## phase.
  if( not Length(result) ) {
    stimuli   <- LookupPhase(phaseName, "Stimuli")
    p <- Parameter( field )
    if( p == "NA" ) {
        result <- []
    } else {
      result <- Repeat( p, Length(stimuli) )
    }    
  }

  return result
} 

########################################################################
#                                                                      #
# This function coordinates trials within a phase.                     #
#                                                                      #
########################################################################

define RunPhase( phaseName ) {
  # Get stimulus settings for this phase. Each line in Phases.csv
  # contains a stimulus entry for a specific phase. Using
  # LookupPhase() we look up which stimuli enter this phase:
  stimuli   <- LookupPhase(phaseName, "Stimuli")
  numTrials <- LookupPhase(phaseName, "Trials")
  rewards   <- LookupPhase(phaseName, "Reward")
  uss       <- LookupPhase(phaseName, "US")
  responses <- LookupPhase(phaseName, "Response")

  ## We build lists trialStimuli and trialRewards to contain stimuli
  ## and rewards repeated as many times as given in 'trials'. The
  ## order of presentation is then randomized by picking stimuli from
  ## a shuffled list 'trialOrder', see end of block
  trialStimuli   <- []
  trialRewards   <- []
  trialUSs       <- []
  trialResponses <- []
  loop( i, Sequence( 1, Length(stimuli), 1 ) ) {
    n <- ToNumber( Nth(numTrials, i) )
    PushOnEnd( trialStimuli,   Repeat( Nth(stimuli,   i), n ) )
    PushOnEnd( trialRewards,   Repeat( Nth(rewards,   i), n ) )
    PushOnEnd( trialUSs,       Repeat( Nth(uss,       i), n ) )
    PushOnEnd( trialResponses, Repeat( Nth(responses, i), n ) )
  }
  trialStimuli   <- Flatten( trialStimuli ) # Nesting is undesired
  trialRewards   <- Flatten( trialRewards )
  trialUSs       <- Flatten( trialUSs )
  trialResponses <- Flatten( trialResponses )
  trialOrder <- Shuffle( Sequence(1, Length(trialStimuli), 1) )

  ## Now we are ready to run all trials:
  maxTrial <- Length( trialStimuli )
  trial    <- 1
  while( trial <= maxTrial ) {
    ## Get stimulus and RewardPr for this trial:
    thisTrial <- Nth(trialOrder, trial)
    stimulus  <- Nth( trialStimuli, thisTrial )
    rewardPr  <- ToNumber( Nth( trialRewards, thisTrial ) )
    uss       <- Nth( trialUSs, thisTrial )
    response  <- Nth( trialResponses, thisTrial )
    ## Run trial and get response times and rewards collected
    results   <- OneTrial( stimulus, rewardPr, uss, response )
    times     <- Nth(results, 1)
    rewards   <- Nth(results, 2)
    ## Save all data to file:
    FilePrintCSV_( gDataFile, Flatten( [ gSubjectInfo, 
      gSex, gAge, phaseName, trial, stimulus, rewardPr, response] ) )
    FilePrint_( gDataFile, "," )
    If( IsList(times) ) {
      FilePrint_( gDataFile, Length(times) + ","+gQuote )
      FilePrintCSV_( gDataFile, times )
      FilePrint_( gDataFile, gQuote+","+gQuote )
      FilePrintCSV_( gDataFile, rewards )
      FilePrint( gDataFile, gQuote )
    } else {
      FilePrint( gDataFile, "0,NA,NA" )
    }
    ## Wait an inter-trial interval and advance to next trial: 
    minITI <- ToNumber( Parameter("MinITI") )
    maxITI <- ToNumber( Parameter("MinITI") )
    Wait( minITI + ( maxITI - minITI )*Random() )
    trial <- trial + 1
  }
}

# Print a list to file in CSF format
define FilePrintCSV_( file, data ) {
  n <- Length(data)
  if( n==1 ) {
    FilePrint_( file, Nth(data,1) )
  } else {
    front <- Subset( data, Sequence(1,n-1,1) )
    loop( d, front ) {
    	if( FindInString( ToString(d), ",", 0) ) {
	  d <- gQuote + d + gQuote 
	}
        FilePrint_( file, d + "," )
    }
    last <- Last(data)
    if( FindInString( ToString(last), ",", 0) ) {
      last <- gQuote + last + gQuote 
    }
    FilePrint_( file, last )
  }
}

# Helper function to identify characteristics of stimuli. Given a
# stimulusName and a field, consults the Stimulus.csv information
# (stored in gStimulusInfo, with header in gStimulusHeader), and
# returns the value of that field for that stimulus. If nothing is
# found, the global parameters are consulted. If nothing is found
# there, "NA" is returned.
define LookupStimulus( sName, field ) {
  nStim <- Length( gStimNames )
  sIndex <- Lookup( sName, gStimNames, Sequence(1,nStim,1) )
  if( IsList(sIndex) ) {
    Message( "Cannot look up '"+field+"' for undefined stimulus "+sName, 1 )
  }  
  nFields <- Length( gStimulusHeader )
  fIndex <- Lookup(field, gStimulusHeader, Sequence(1,nFields,1) )
  if( IsList(fIndex) ) { # Did not find field, try global parameters
    result <- Parameter( field )
  } else {
    result <- Nth( Nth( gStimulusInfo, sIndex ), fIndex )
    if( not StringLength(result) ) { # Empty field, try global parameters
      result <- Parameter( field )
    }
  }
  return result
}

# Resolve the value in a stimulus field expressed in :/* syntax. If
# the value starts with :, the rest is expected to be a stimulus name,
# and the value of the field for that stimulus named is
# substituted. If the value start with *, we look up in the subject
# information for a field of the form 'value+field', and we substitute
# that value (here 'value' is stripped of the initial *). If nothing
# is found, try to lookup something in the global parameters.
define Resolve( field, value ) {
  values <- SplitString( value, "+" )
  results <- []
  loop( i, Sequence(1,Length(values),1) ) {
    value <- Nth( values, i )
    if( SubString(value,1,1) == ":" ) {
      # This is the stimulus to be looked up:
      s <- SubString(value,2,StringLength(value)-1)
      PushOnEnd( results, LookupStimulus( s, field ) )
    } elseif( Substring(value,1,1) == "*" ) {
      s <- SubString(value,2,StringLength(value))
      PushOnEnd( results, Lookup( s+field, gSubjectHeader, gSubjectInfo ) )
    } else {
      PushOnEnd( results, value )
    }
  }
  if( Length(results)==1 ) {
    results <- First( results )
  }
  return results
}

# Interpret a 'color' string from Stimulus.csv, and return the
# corresponding PEBL Color object. Read through to see how colors can
# be specified 
define MakeColorRGBString( color ) {
  ## We see whether color is a name or RGB triplet, and act
  ## accordingly:
  components <- SplitString( color, "," )
  if( Length(components) != 3 ) { ## treat as color name
    c <- MakeColor( color )
  } else {
    cred <- ToNumber( Nth(components, 1) )
    cgreen <- ToNumber( Nth(components, 2) )
    cblue <- ToNumber( Nth(components, 3) )
    c <- MakeColorRGB( cred, cgreen, cblue )
  }
  return c
}

define Message( text, fatal ) {
  box <- MakeTextBox( text, gFont, .9*gVideoWidth, .9*gVideoHeight )
  AddObject( box, gWindow )
  Move( box, .05*gVideoWidth, .05*gVideoHeight )
  Draw()
  WaitForKeyDown(" ")
  RemoveObject( box, gWindow )
  Draw()
  if( fatal ) {
    SignalFatalError( text )
  }
}

########################################################################
#                                                                      #
# In this section we have functions reading files in the Design        #
# directory to configure the experiment, and a few accessory functions #
#                                                                      #
########################################################################

## The two next functions implement a simple file locking mechanism

define LockFile( file ) {
  while( FileExists( file + ".lck" ) ) {
    Wait( 250 )
  }
  FileOpenOverWrite( file + ".lck" ) 
}

define UnlockFile( file ) {
  if( FileExists( file + ".lck" ) ) {
    DeleteFile( file + ".lck" )
  }
}

define ReadSubject() {
  subjectsFile <- gWD + "Design/Subjects.csv"
  LockFile( subjectsFile )
  subjects <- ReadCSV( subjectsFile )
  gSubjectHeader <- Nth( subjects, 1 )
  found <- 0
  if( not IsDirectory( gWD + "Data" ) ) {
    MakeDirectory( gWD + "Data" )
  }
  loop( s, Rest(subjects) ) {
    dataFilename <- gWD + "Data/" + Nth(s,1) + ".dat"
    if( not FileExists(dataFilename) ) {
      found <- 1
      Print_( "Running subject: " )
      PrintList( s )
      break
    }
  }
  ## Open data file before releasing lock, to prevent race conditions
  if( found ) {
    gSubjectInfo <- s
    gDataFile <- FileOpenWrite( dataFilename )
    UnlockFile( subjectsFile )
  } else {
    UnlockFile( subjectsFile )
    text <- "It looks like all subjects have been run! 

Press 'q' to quit"
    box <- MakeTextBox( text, gFont, .8*gVideoWidth, gVideoHeight )
    AddObject( box, gWindow )
    Move( box, .1*gVideoWidth, .1*gVideoHeight )
    Draw()
    WaitForKeyDown("q")
  }
}

define ReadStimuli() {
  csv <- ReadCSV( gWD + "Design/Stimuli.csv" )
  gStimulusHeader <- First( csv )
  gStimulusInfo <- Rest( csv )
  gStimNames <- []
  gStimTypes <- []
  gStimParams <- []
  gStimColors <- []
  gStimXOffsets <- []
  gStimYOffsets <- []
  loop( s, gStimulusInfo ) {
    PushOnEnd( gStimNames, Nth( s, 1 ) )
    PushOnEnd( gStimTypes, Nth( s, 2 ) )
    PushOnEnd( gStimParams, Nth( s, 3 ) )
    PushOnEnd( gStimColors, Nth( s, 4 ) )
    PushOnEnd( gStimXOffsets, Nth( s, 5 ) )
    PushOnEnd( gStimYOffsets, Nth( s, 6 ) )
  }
  ## Check there are no duplicate stimulus names
  if( Length(gStimNames) != Length( Levels(gStimNames) ) ) {
    Message("Duplicate in stimulus names: "+gStimNames, 1)
  }
  ## Now we are ready to create the stimulus objects
  gStimuli <- []
  n <- Length( gStimNames )
  loop( i, Sequence(1,n,1) ) {
    type <- Nth( gStimTypes, i )
    if( StringLength( Nth( gStimColors, i ) ) ) {
      ## Determine colors:
      colors <- SplitString( Resolve("Color",Nth(gStimColors, i)), "+" )
      c1name <- Nth( colors, 1 )
      if( StringLength(c1name) ) {
        c1 <- MakeColorRGBString( c1name )
      } else {
        c1 <- gColor
      }
      if( Length(colors) == 2 ) {
        c2name <- Nth( colors, 2 )
	if( StringLength( c2name ) ) {
	  c2 <- MakeColorRGBString( c2name )
        } else {
          c2 <- gBackgroundColor
        }
      } else {
        c2 <- gBackgroundColor
      }    
    } else {
      c1 <- gColor
      c2 <- gBackgroundColor
    }
    ## Create a font for text stimuli    
    font <- MakeFont( Parameter("FontName")+".ttf", 0, 
                      ToNumber(Parameter("FontSize")), c1, c2, 1 )
    x <- ToNumber( Resolve( "XOffset", Nth( gStimXOffsets, i ) ) )
    y <- ToNumber( Resolve( "YOffset", Nth( gStimYOffsets, i ) ) )
    x <- x + gVideoWidth/2
    y <- y + gVideoHeight/2
    if(  type == "circle" ) {
      r <- ToNumber( Resolve( "Parameters", Nth(gStimParams,i) ) )
      s <- Circle( x, y, r, c1, 1 )
    } elseif( type == "square" ) {
      l <- ToNumber( Resolve( "Parameters", Nth(gStimParams,i) ) )
      s <- Square( x, y, l, c1, 1 )
    } elseif( type == "image" ) {
      p <- Resolve( "Parameters", Nth(gStimParams,i) )
      if( IsList(p) ) { # More than one parameter
        file <- First(p)
	zoom <- Nth(p, 2)
      }  else {
        file <- p
	zoom <- 1
      }
      fileLocal <- gWD + "Materials/" + file
      fileAlex <- gAlexDir + file
      Print( fileLocal )
      Print( fileAlex )
      if( FileExists( fileLocal ) ) {
        s <- MakeImage( fileLocal )
      } elseif( FileExists( fileAlex ) ) {
        s <- MakeImage( fileAlex )
      } else {
        s <- MakeImage( file )
      }
      s.ZOOMX <- zoom
      s.ZOOMY <- zoom
      Move( s, x, y )
    } elseif( type == "text" ) {
      w <- Resolve( "Parameters", Nth(gStimParams,i) )
      s <- MakeLabel( w, font )
      Move( s, x, y )
    } elseif( type == "textfile" ) {
      fileName <- Resolve( "Parameters", Nth(gStimParams,i) )
      text <- FileReadText( gWD + "Materials/" + fileName )
      s <- MakeTextBox( text, font, .9*gVideoWidth, .9*gVideoHeight )
      Move( s, .05*gVideoWidth, .05*gVideoHeight )
    } elseif( type == "sound" ) {
       f <- Resolve( "Parameters", Nth(gStimParams,i) )
       s <- LoadSound( gWD + "Materials/" + f )
    # Movies will be supported when PEBL supports them better:
    # } elseif( type == "movie" ) {
    #   p <- Resolve( "Parameters", Nth(gStimParams,i) )
    #   p <- SplitString( p, "+" )      
    #   f <- gWD + "Materials/" + Nth( p, 1 )
    #   width <- Nth( p, 2 )
    #   height <- Nth( p, 3 )
    #   s <- LoadMovie( f, gWindow, width, height )
    #   if( not s ) {
    #     Message( "Cannot load movie file "+f, 1 )
    #   }
    #   Move( s, x - width/2, y - height/2 )
    } else {
       Message( "Unsupported stimulus type: "+type, 1 )
    }
    PushOnEnd( gStimuli, s )
    AddObject( s, gWindow )
    Hide( s )
    #Print_( "Read stimulus: " + s )
  }
}

define ReadPhases() {
  csv <- ReadCSV( gWD + "Design/Phases.csv" )
  gPhaseHeader <- First( csv )
  gPhases <- Transpose( Rest( csv ) )
}

define ReadParameters() {
  csv <- Transpose( Rest( ReadCSV( gWD + "Design/Parameters.csv" ) ) )
  gParameterNames <- Nth(csv, 1)
  gParameterValues <- Nth(csv, 2)
  loop( i, Sequence(1,Length(gParameterNames),1) ) {
    Print( Nth(gParameterNames,i)+" = "+Nth(gParameterValues,i) )
  }
}

define Parameter( name ) {
  value <- Lookup( name, gParameterNames, gParameterValues )
  If( IsList(value) ) {
    value <- "NA"
  }
  return value
}