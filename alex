#!/usr/local/bin/pebl-language

# Breakdown of the Start function:
#
# - Read command-line arguments
# - Read design parameters from Parameters.csv
# - Initialize basic display elements
# - Read Design files Subjects.csv, Phases.csv, Stimuli.csv
# - Show instructions from Instructions.txt
# - Get demographics info from subject
# -  

define Start( par ) {
  ## 'alex -v test' skips instructions and demographics collection:
  if( IsList(par) and Sum( Match( par, "test" ) ) ) {
    test <- 1
  } else {
    test <- 0
  }
  ## Read Design/Parameters.csv:
  ReadParameters()
  ## Initialize basic display elements:
  fg <- Parameter( "ForegroundColor" )
  bg <- Parameter( "BackgroundColor" )
  gWindow <- MakeWindow( bg )
  gBackgroundColor <- MakeColor( bg )
  gColor <- MakeColor( fg )
  gFont <- MakeFont( Parameter("FontName")+".ttf", 0, 
    ToNumber(Parameter("FontSize")), gColor, gBackgroundColor, 1 )
  ## Read other Design files:
  ReadSubjectInfo()
  ReadPhases()     
  ReadStimuli()    

  if( not test ) {
    ShowInstructions()
  }

  if( test ) {
    gSex <- "NA"
    gAge <- "NA"
  } else {
    gSex <- GetEasyChoice( "Please select your sex", 
    	 ["Male", "Female"], ["M", "F"], gWindow )
    gAge <- GetEasyInput( "Please enter your age in years, "+
      "then press enter:", gWindow )
    gAge <- ToInteger( gAge )
  }

  if( not test ) {
    Message( "Press the spacebar to start the experiment", 0 )
    Wait( 2000 )
  }

  ShowCursor( 0 )

  ## Print datafile header (gDataFile has been opened by
  ## ReadSubjectInfo() to avoid race conditions with acquiring and
  ## releasing the lock to Subjects.csv)
  loop( field, gSubjectHeader ) {
    FilePrint_( gDataFile, field + "," )
  } 
  FilePrint( gDataFile, 
    "Sex,Age,Phase,Trial,Stimulus,RewardPr,Responses,RTs,Rewards" )

  loop( p, Levels(Lookup("Phase",gPhaseHeader,gPhases))  ){
    RunPhase( p )
  }

  FileClose( gDataFile )
  ShowEnd()
  ShowCursor( 1 )
}

########################################################################
#                                                                      #
# This function coordinates the events within a single trial           #
#                                                                      #
########################################################################

define OneTrial( stimulus, rewardProb, uss ) {
  Draw()
  n <- Length( gStimNames )
  trialStimuli <- []
  # The 'stimulus' may actually be a compound, so we split it into
  # individual letters and we build a list of stimuli for this trial
  # by looking the stimulus objects up in the gStimuli list.
  loop( stimName, SplitString(stimulus, "") ) {
  	i <- Lookup( stimName, gStimNames, Sequence(1,n,1) )
	PushOnEnd( trialStimuli, Nth( gStimuli, i ) )
  }
  # Now we show all stimulus objects
  loop( stim, trialStimuli ) {
    Display( stim )
  }
  Draw()
  maxResponses <- ToNumber( Parameter("MaxResponses") )
  csDuration   <- ToNumber( Parameter("CSDuration") )
  csusInterval <- ToNumber( Parameter("CSUSInterval") )
  usDuration   <- ToNumber( Parameter("USDuration") )
  times        <- []
  rewards      <- []
  timeLeft     <- ToNumber( csDuration )
  startTime    <- GetTime()
  while( Length(times)<maxResponses and timeLeft>1 ) {
    key <- WaitForListKeyPressWithTimeout([" "], timeLeft, 1 )
    rt <- GetTime() - startTime
    timeLeft <- csDuration - rt
    if( timeLeft > 1 ) {
      PushOnEnd( times, rt )
      if( Random() < rewardProb ) {
        PushOnEnd( rewards, 1 )
        Wait( csusInterval )
	loop( us, SplitString( uss, "," ) ) {
          Display( Lookup( us, gStimNames, gStimuli ) )
        }
        Draw()
        Wait( usDuration )
	loop( us, SplitString( uss, "," ) ) {
          Undisplay( Lookup( us, gStimNames, gStimuli ) )
        }
        Draw()
      } else {
        PushOnEnd( rewards, 0 )
      }
    }
  }
  loop( stim, trialStimuli ) {
    Undisplay( stim )
  }
  Draw()
  if( not Length(times) ) {
    times <- "NA"
    rewards <- "NA"
  }
  return [times, rewards]
}

########################################################################
#                                                                      #
# This function coordinates trials within a phase.                     #
#                                                                      #
########################################################################

# Helper function to identify what goes into a phase
define LookupPhase( phaseName, field ) {
  fields <- Lookup(field, gPhaseHeader,gPhases)
  if( not Length(fields) ) {
    result <- []
  } else {
    idx <- Match( Lookup("Phase",gPhaseHeader,gPhases), phaseName) 
    result <- Filter( fields, idx )
  }
  return result
} 

define RunPhase( phaseName ) {
  # Get stimulus settings for this phase. Each line in Phases.csv
  # contains a stimulus entry for a specific phase.
  stimuli   <- LookupPhase(phaseName, "Stimuli")
  numTrials <- LookupPhase(phaseName, "Trials")
  rewards   <- LookupPhase(phaseName, "Rewards")
  uss       <- LookupPhase(phaseName, "USs")
  ## Stimulus durations are optional. If they are not given, we
  ## construct them using the value of the CSDuration global parameter:
  durations <- LookupPhase(phaseName, "Durations")
  if( not Length(durations) ) {
    durations <- Repeat( Parameter("CSDuration"), Length(stimuli) )
  }

  ## trialStimuli and trialRewards contain stimuli and rewards
  ## repeated as many times as given in 'trials'. The order of
  ## presentation is then randomized by picking stimuli from a
  ## shuffled list 'trialOrder', see end of block
  trialStimuli <- []
  trialRewards <- []
  trialUSs     <- []
  loop( i, Sequence( 1, Length(stimuli), 1 ) ) {
    n <- ToNumber( Nth(numTrials, i) )
    PushOnEnd( trialStimuli, Repeat( Nth(stimuli, i), n ) )
    PushOnEnd( trialRewards, Repeat( Nth(rewards, i), n ) )
    PushOnEnd( trialUSs,     Repeat( Nth(uss,     i), n ) )
  }
  trialStimuli <- Flatten( trialStimuli ) # Nesting is undesired
  trialRewards <- Flatten( trialRewards )
  trialUSs     <- Flatten( trialUSs )
  trialOrder <- Shuffle( Sequence(1, Length(trialStimuli), 1) )

  maxTrial <- Length( trialStimuli )
  trial    <- 1
  while( trial <= maxTrial ) {
    ## Get stimulus and RewardPr for this trial:
    thisTrial <- Nth(trialOrder, trial)
    stimulus  <- Nth( trialStimuli, thisTrial )
    rewardPr  <- ToNumber( Nth( trialRewards, thisTrial ) )
    uss       <- Nth( trialUSs, thisTrial )
    ## Run trial and get response times and rewards collected
    results   <- OneTrial( stimulus, rewardPr, uss, durations )
    times     <- Nth(results, 1)
    rewards   <- Nth(results, 2)
    ## Save all data to file:
    FilePrintCSV_( gDataFile, Flatten( [ gSubjectInfo, 
      gSex, gAge, phaseName, trial, stimulus, rewardPr] ) )
    FilePrint_( gDataFile, "," )
    If( IsList(times) ) {
      FilePrint_( gDataFile, Length(times) + ","+gQuote )
      FilePrintCSV_( gDataFile, times )
      FilePrint_( gDataFile, gQuote+","+gQuote )
      FilePrintCSV_( gDataFile, rewards )
      FilePrint( gDataFile, gQuote )
    } else {
      FilePrint( gDataFile, "0,NA,NA" )
    }
    ## Wait an inter-trial interval and advance to next trial: 
    minITI <- ToNumber( Parameter("MinITI") )
    maxITI <- ToNumber( Parameter("MinITI") )
    Wait( minITI + ( maxITI - minITI )*Random() )
    trial <- trial + 1
  }
}

# Print a list to file in CSF format
define FilePrintCSV_( file, data ) {
  n <- Length(data)
  if( n==1 ) {
    FilePrint_( file, Nth(data,1) )
  } else {
    front <- Subset( data, Sequence(1,n-1,1) )
    loop( d, front ) {
    	if( FindInString( ToString(d), ",", 0) ) {
	  d <- gQuote + d + gQuote 
	}
        FilePrint_( file, d + "," )
    }
    last <- Last(data)
    if( FindInString( ToString(last), ",", 0) ) {
      last <- gQuote + last + gQuote 
    }
    FilePrint_( file, last )
  }
}

define ShowInstructions() {
  instrText <- FileReadText("Design/Instructions.txt")
  instrText <- instrText
  instrFont <- MakeFont("Vera.ttf", 0, 24, gColor, gBackgroundColor, 1 )
  instrBox  <- MakeTextBox(instrText, instrFont, 
                 .9*gVideoWidth, .95*gVideoHeight)
  AddObject( instrBox, gWindow )
  Move( instrBox, .05*gVideoWidth, .05*gVideoHeight )
  Draw()
  WaitForKeyDown(" ")
  RemoveObject( instrBox, gWindow )
  Draw()
  Wait( 1000 )
}

define ShowEnd() {
  endText <- "You're done, thanks for your participation!

You will now receive a handout with an explanation of the experiment."
  endBox <- MakeTextBox( endText, gFont, .8*gVideoWidth, gVideoHeight )
  AddObject( endBox, gWindow )
  Move( endBox, .1*gVideoWidth, .1*gVideoHeight )
  Draw()
  WaitForKeyDown("q")
}

# Interpret a 'color' string from Stimulus.csv, and return the
# corresponding PEBL Color object. Read through to see how colors can
# be specified 
define MakeColorRGBString( color ) {
  ## If 'color' starts with '=', we expect a stimulus name after, and
  ## we use that stimulus' color:
  if( SubString(color,1,1) == "=" ) {
    s <- SubString(color,2,StringLength(color)-1)
    color <- Lookup( s, gStimNames, gStimColors )
    if( IsList(color) ) {
      Message("Can't find stimulus "+s+" in color substitution", 1)
    }
  }
  ## If 'color' starts with '*', we look up the color in gSubjectInfo:
  if( SubString(color,1,1) == "*" ) {
    stimulus <- SubString(color,2,1) 
    color <- Lookup( stimulus+"Color", gSubjectHeader, gSubjectInfo )
  }
  ## Now we see whether color is a name or RGB triplet, and act
  ## accordingly:
  components <- SplitString( color, "," )
  if( Length(components) != 3 ) { ## treat as color name
    c <- MakeColor( color )
  } else {
    cred <- ToNumber( Nth(components, 1) )
    cgreen <- ToNumber( Nth(components, 2) )
    cblue <- ToNumber( Nth(components, 3) )
    c <- MakeColorRGB( cred, cgreen, cblue )
  }
  return c
}

define Display( s ) {
  if( IsAudioOut(s) ) {
    PlayBackground( s )
  } else {
    Show( s )
  }
}

define Undisplay( s ) {
  if( not IsAudioOut(s) ) {
    Hide( s )
  }
}

define Message( text, fatal ) {
  box <- MakeTextBox( text, gFont, .9*gVideoWidth, .9*gVideoHeight )
  AddObject( box, gWindow )
  Move( box, .05*gVideoWidth, .05*gVideoHeight )
  Draw()
  WaitForKeyDown(" ")
  RemoveObject( box, gWindow )
  Draw()
  if( fatal ) {
    SignalFatalError( text )
  }
}

########################################################################
#                                                                      #
# In this section we have functions reading files in the Design        #
# directory to configure the experiment, and a few accessory functions #
#                                                                      #
########################################################################

## The two next functions implement a simple file locking mechanism

define LockFile( file ) {
  while( FileExists( file+".lck" ) ) {
    Wait( 250 )
  }
  FileOpenOverWrite( file+".lck" ) 
}

define UnlockFile( file ) {
  if( FileExists( file+".lck" ) ) {
    SystemCall( "/bin/rm " + file + ".lck" )
  }
}

define ReadSubjectInfo() {
  subjectsFile <- "Design/Subjects.csv"
  LockFile( subjectsFile )
  subjects <- ReadCSV( subjectsFile )
  gSubjectHeader <- Nth( subjects, 1 )
  found <- 0
  if( not IsDirectory( "Data" ) ) {
    MakeDirectory( "Data" )
  }
  loop( s, Rest(subjects) ) {
    dataFilename <- "Data/" + Nth(s,1) + ".dat"
    if( not FileExists(dataFilename) ) {
      found <- 1
      Print_( "Running subject: " )
      PrintList( s )
      break
    }
  }
  ## Open data file before releasing lock, to prevent race conditions
  if( found ) {
    gSubjectInfo <- s
    gDataFile <- FileOpenWrite( dataFilename )
    UnlockFile( subjectsFile )
  } else {
    UnlockFile( subjectsFile )
    text <- "It looks like all subjects have been run!

Press 'q' to quit"
    box <- MakeTextBox( text, gFont, .8*gVideoWidth, gVideoHeight )
    AddObject( box, gWindow )
    Move( box, .1*gVideoWidth, .1*gVideoHeight )
    Draw()
    WaitForKeyDown("q")
  }
}

define ReadStimuli() {
  csv <- ReadCSV( "Design/Stimuli.csv" )
  gStimNames <- []
  gStimShapes <- []
  gStimParams <- []
  gStimColors <- []
  gStimXOffsets <- []
  gStimYOffsets <- []
  loop( s, Rest( csv ) ) {
    PushOnEnd( gStimNames, Nth( s, 1 ) )
    PushOnEnd( gStimShapes, Nth( s, 2 ) )
    PushOnEnd( gStimParams, Nth( s, 3 ) )
    PushOnEnd( gStimColors, Nth( s, 4 ) )
    PushOnEnd( gStimXOffsets, Nth( s, 5 ) )
    PushOnEnd( gStimYOffsets, Nth( s, 6 ) )
  }
  ## Check there are no duplicate stimulus names
  if( Length(gStimNames) != Length( Levels(gStimNames) ) ) {
    Message("Duplicate in stimulus names: "+gStimNames, 1)
  }
  ## Now we are ready to create the stimulus objects
  gStimuli <- []
  n <- Length( gStimNames )
  loop( i, Sequence(1,n,1) ) {
    if( StringLength( Nth( gStimColors, i ) ) ) {
      c <- MakeColorRGBString( Nth( gStimColors, i ) )
    }
    x <- gVideoWidth/2 + ToNumber(Nth( gStimXOffsets, i ))
    y <- gVideoHeight/2 + ToNumber(Nth( gStimYOffsets, i ))
    type <- Nth( gStimShapes, i )
    if(  type == "circle" ) {
       r <- ToNumber( Nth(gStimParams,i) )
       s <- Circle( x, y, r, c, 1 )
    } elseif( type == "square" ) {
       l <- ToNumber( Nth(gStimParams,i) )
       s <- Square( x, y, l, c, 1 )
    } elseif( type == "image" ) {
       f <- Nth(gStimParams,i)
       s <- MakeImage( "Media/" + f )
       Move( s, x, y )
    } elseif( type == "text" ) {
       w <- Nth(gStimParams,i)
       s <- MakeLabel( w, gFont )
       Move( s, x, y )
    } elseif( type == "sound" ) {
       f <- Nth(gStimParams,i)
       s <- LoadSound( "Media/" + f )
    } else {
       Message( "Unsupported stimulus type: "+type, 1 )
    }
    PushOnEnd( gStimuli, s )
    AddObject( s, gWindow )
    Hide( s )
  }
}

define ReadPhases() {
  csv <- ReadCSV( "Design/Phases.csv" )
  gPhaseHeader <- First( csv )
  gPhases <- Transpose( Rest( csv ) )
}

define ReadParameters() {
  csv <- Transpose( Rest( ReadCSV( "Design/Parameters.csv" ) ) )
  gParameterNames <- Nth(csv, 1)
  gParameterValues <- Nth(csv, 2)
  loop( i, Sequence(1,Length(gParameterNames),1) ) {
    Print( Nth(gParameterNames,i)+" = "+Nth(gParameterValues,i) )
  }
}

define Parameter( name ) {
  n <- Length( gParameterNames )
  value <- Lookup( name, gParameterNames, gParameterValues )
  if(  IsList(value) ) {
    Message("Parameter "+name+" not found, or multiply defined", 1)
  }
  return value
}