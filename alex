#!/usr/bin/pebl

define Start( par ) {

  ## This is the folder where we look for support files. In contrast
  ## to alex-init, we might not need these files, so not finding
  ## anything is not an error. We look through a number of likely
  ## system directories anyway, stopping as soon as we find one.
  gAlexDir <- "Library/Materials/"
  dirs <- [ "",                # Current folder takes precedence
            "/usr/share/alex/" # Linux
            # ADD OS X AND WINDOWS
          ]
  loop( d, dirs ) {
    if( IsDirectory( d + gAlexDir ) ) {
      gAlexDir <- d + gAlexDir
      Print( "alex: Found system folder " + gAlexDir )
      break
    }
  }

  # Have we been asked to run in a directory other than .?
  gWD <- Nth(par, 1)
  if( gWD != 0 ) {
    gWD <- gWD + "/"
    if( not IsDirectory( gWD ) ) {
      SignalFatalError("alex: Command line argument "+gWD+" is not a folder")
    }
  } else {
    gWD <- ""
  }

  # Get hostname for recording in data lines
  if( not IsDirectory( gWD + "Data" ) ) {
    MakeDirectory( gWD + "Data" )
  }
  SystemCall( "hostname > "+gWD+"Data/temp.txt" )
  tmp <- FileOpenRead( gWD+"Data/temp.txt" )
  gHostname <- FileReadLine( tmp )
  FileClose( tmp )

  ReadParameters()

  # Determine whether to run in test mode or not:
  test <- Parameter("Test")
  if( test != "NA" and ToNumber(test) == 1 ) {
    test <- 1
  } else {
    test <- 0
  }
  
  ## Initialize basic display elements:
  fg <- Parameter( "ForegroundColor" )
  if( fg == "NA" ) {
    fg <- "white"
  }
  bg <- Parameter( "BackgroundColor" )
  if( bg == "NA" ) {
    bg <- "black"
  }
  gWindow <- MakeWindow( bg )
  gBackgroundColor <- MakeColor( bg )
  gColor <- MakeColor( fg )
  fontname <- Parameter("FontName")
  if( fontname == "NA" ) {
    fontname <- "Vera"
  }
  fontsize <- Parameter("FontSize")
  if( fontsize == "NA" ) {
    fontsize <- 24
  }
  gFont <- MakeFont( fontname+".ttf", 0, 
    ToNumber(fontsize), gColor, gBackgroundColor, 1 )

  ## Read other Design files:
  ReadSubject()
  ReadPhases()     
  ReadStimuli()    

  ## Subject information is only asked when not running in test mode
  if( not test ) {
    gSex <- GetEasyChoice( "Please select your sex", 
       ["Male", "Female"], ["M", "F"], gWindow )
    gAge <- GetEasyInput( "Please enter your age in years, "+
      "then press enter:", gWindow )
    gAge <- ToInteger( gAge )
    Message( "Press the spacebar to start the experiment", 0 )
    Wait( 2000 )
  } else {
    gSex <- "NA"
    gAge <- "NA"
  }

  ShowCursor( 0 )

  ## Print data file header. gDataFile has been opened by
  ## ReadSubject() to avoid race conditions with acquiring and
  ## releasing the lock to Groups.csv. We first print the hostname,
  ## followed by whatever fields are defined in Groups.csv (stored in
  ## gSubjectHeader), then fields for other data:
  FilePrintCSV( gDataFile, Flatten( ["Hostname",gSubjectHeader, 
    "Sex","Age","Phase","Trial","Stimulus","Response","RewardPr",
     "Key","RT","ResponseCount","Reward"] ) )

  ## Create a global list of possible keys
  gKeys <- []
  kc <- [8,9,12,13,27]
  PushOnEnd( kc, Sequence(32,64,1) )
  PushOnEnd( kc, Sequence(91,127,1) )
  PushOnEnd( kc, Sequence(256,310,1) )
  loop( c, Flatten(kc) ) {
    PushOnEnd( gKeys, TranslateKeyCode(c) )
  }

  ## Run experimental phases. We loop through all elements of the
  ## Phase column in Phases.csv. Phase p is run with RunPhase( p ),
  ## and we keep track of the phases already run in the alreadyRun
  ## list. The reason is that each phase name appears multiple times
  ## in the Phase column when the phase features multiple
  ## stimuli. RunPhase() looks for all stimuli pertaining to a phase,
  ## so we have to call it only once per phase.
  alreadyRun <- []
  loop( p, Lookup("Phase",gPhaseHeader,gPhases)  ){
    if( not Sum( Match( alreadyRun, p ) ) ) {
      RunPhase( p )
      PushOnEnd( alreadyRun, p )
    }
  }

  FileClose( gDataFile )
  ShowCursor( 1 )
}

########################################################################
#                                                                      #
# Display and Undisplay are two utility functions that can show and    #
# hide multiple visual stimuli, and also start and pause the playback  #
# of audio stimuli.                                                    #
#                                                                      #
########################################################################

define Display( stimulus ) {
  # The 'stimulus' may actually be a compound, like "A+B", so we split
  # it into individual stimuli and then display each of them. We look
  # up the stimulus objects in the gStimuli list.
  n <- Length( gStimNames )
  loop( stimName, SplitString(stimulus, "+") ) {
    i <- Lookup( stimName, gStimNames, Sequence(1,n,1) )
    s <- Nth( gStimuli, i )
    if( IsAudioOut(s) ) {
      StartPlayback( s )
    } else {
      Show( s )
    }
  }
  Draw()
}

define Undisplay( stimulus ) {
  n <- Length( gStimNames )
  loop( stimName, SplitString(stimulus, "+") ) {
    i <- Lookup( stimName, gStimNames, Sequence(1,n,1) )
    s <- Nth( gStimuli, i )
    if( IsAudioOut(s) ) {
      PausePlayback( s )
    } else {
      Hide( s )
    }
  }
  Draw()
}

# Helper function to determine the duration of stimuli. Note: the way
# we can get "NA" below is the following: if LookupStimulus() does not
# find anyting specific, it calls Parameter(). If this does not find
# anything, it returns "NA", which is returned back by
# LookupStimulus(). Because Resolve() does not modify "NA", we can get
# it back and detect that no specific stimulus duration has been
# specified, so we can look up CSDuration or USDuration (as specifice
# dby 'role'). Sorry for the complication.
define ResolveDuration( stimulus, role ) {
  durations <- []
  loop( s, SplitString(stimulus,"+") ) {
    d <- First(Resolve( "Duration", LookupStimulus( s, "Duration" ) ))
    if( d == "NA" ) { # See Note above
      d <- Parameter( role + "Duration")
    }
    d <- ToNumber( d ) # NA becomes 0
    PushOnEnd( durations, d )
  }
  ## If any duration is 0 (could not be determined), we have an error:
  if( Sum( Match( durations, 0 ) ) ) {
    Message( "Could not determine duration of " + stimulus, 1 )
  }
  ## The duration information is valid if all durations are equal
  d <- First( durations )
  loop( d2, Rest( durations ) ) {
    if( d != d2 ) {
      Message( "Some stimuli have different durations in "+stimulus, 1 )
    }
  } 
  return d
}

########################################################################
#                                                                      #
# This function coordinates the events within a single trial           #
#                                                                      #
########################################################################

define RunTrial( phase, trial, stimulus, rewardProb, uss, response, 
                 maxResponses ) {
  Draw()
  # Determine CS and US duration:
  csDuration <- ToNumber( ResolveDuration( stimulus, "CS" ) )
  if( rewardProb>0 ) {
    usDuration <- ToNumber( ResolveDuration( uss, "US" ) )
  } else {
    usDuration <- "NA"
  }
  # Determine some other parameters:
  csusInterval <- Parameter("CSUSInterval")
  if( csusInterval == "NA" ) {
    csusInterval <- 0
  } else {
    csusInterval <- ToNumber( csusInterval )
  }
  rtMin <- Parameter("ReactionTimeMin")
  if( rtMin == "NA" ) {
    rtMin <- 0
  } else {
    rtMin <- ToNumber( rtMin )
  }
  rtMax <- Parameter("ReactionTimeMax")
  if( rtMax == "NA" ) {
    rtMax <- csDuration
  } else {
    rtMax <- ToNumber( rtMax )
  }
  # Preprocess the response variable to handle the special "space" key
  # and the "*" specification for 'classical' trials:
  classical <- 0
  if( response == "space" ) {
    correct <- " "
  } elseif( SubString(response,1,1) == "*" ) {
    classical <- 1
    correct <- SubString(response,2,StringLength(response)-1)
  } else {
    correct <- response
  }
  # We are ready to run the trial loop. The trial continues until
  # either time runs out or we reach the maximum number of (valid)
  # responses.
  timeLeft     <- ToNumber( csDuration )
  startTime    <- GetTime()
  responseCount <- 0
  reward <- 0
  Display( stimulus )
  while( responseCount<maxResponses and timeLeft>1 ) {
    key <- WaitForListKeyPressWithTimeout( gKeys, timeLeft, 1 )
    rt <- GetTime() - startTime
    timeLeft <- csDuration - rt
    # If we did not time out we have to process the response:
    if( timeLeft > 1 ) {
      responseCount <- responseCount + 1
      if( classical == 0 ) {
        # If response is invalid, reward is -1:
        if( rt<rtMin or rt>rtMax ) {
          reward <- -1
        # If response is valid and rewarded, reward is 1:
        } elseif( Random() < rewardProb and key == correct ) {
          reward <- 1
          Wait( csusInterval )
          Display( uss )
          Wait( usDuration )
          Undisplay( uss )
        # If response is valid but unrewarded, reward is 0:
        } else {
          reward <- 0
        }
      } elseif( Random() < rewardProb and reward == 0 ) {
        reward <- 1
      }
    # If response timed out, count and reward are NA
    } else {
      responseCount <- "NA"
      reward <- "NA"
    }
    # Update timeLeft again because US display may have used time
    timeLeft <- csDuration - GetTime() + startTime

    ## Save data line to file:
    FilePrintCSV( gDataFile, Flatten( [ gHostname, gSubjectInfo, 
      gSex, gAge, phase, trial, stimulus, response, 
      rewardProb, key, rt, responseCount, reward ] ) )
  }
  Undisplay( stimulus )
  Draw()
  ## This happens at the end of a 'classical conditioning' trial. 
  if( classical == 1 and reward == 1 ) {
    Display( uss )
    Wait( usDuration )
    Undisplay( uss )
  }
}

# Helper function to identify what enters a phase. If we don't find a
# field in the phase header, we try to see whether it is defined as a
# global parameter (if that fails, we get NAs and we return those).
define LookupPhase( phaseName, field ) {
  fields <- Lookup(field, gPhaseHeader, gPhases)
  if( not Length(fields) ) { 
    stimuli <- LookupPhase( phaseName, "Stimuli" )
    result <- Repeat( Parameter(field), Length(stimuli) )
  } else {
    idx <- Match( Lookup("Phase", gPhaseHeader, gPhases), phaseName) 
    tempResult <- Filter( fields, idx )
    result <- []
    loop( r, tempResult ) {
      if( not StringLength(r) ) {
        r <- Parameter(field)
      }
      PushOnEnd( result, r )
    }
  }
  return result
} 

########################################################################
#                                                                      #
# This function coordinates trials within a phase.                     #
#                                                                      #
########################################################################

define RunPhase( phaseName ) {
  # Get stimulus settings for this phase. Each line in Phases.csv
  # contains a stimulus entry for a specific phase. Using
  # LookupPhase() we look up which stimuli enter this phase:
  stimuli      <- LookupPhase(phaseName, "Stimuli")
  numTrials    <- LookupPhase(phaseName, "Trials")
  rewards      <- LookupPhase(phaseName, "Reward")
  uss          <- LookupPhase(phaseName, "US")
  responses    <- LookupPhase(phaseName, "Response")
  maxResponses <- LookupPhase(phaseName, "MaxResponses")

  ## We build lists trialStimuli and trialRewards to contain stimuli
  ## and rewards repeated as many times as given in 'trials'. The
  ## order of presentation is then randomized by picking stimuli from
  ## a shuffled list 'trialOrder', see end of block
  trialStimuli      <- []
  trialRewards      <- []
  trialUSs          <- []
  trialResponses    <- []
  trialMaxResponses <- []
  loop( i, Sequence( 1, Length(stimuli), 1 ) ) {
    n <- ToNumber( Nth(numTrials, i) )
    PushOnEnd( trialStimuli,      Repeat( Nth(stimuli,      i), n ) )
    PushOnEnd( trialRewards,      Repeat( Nth(rewards,      i), n ) )
    PushOnEnd( trialUSs,          Repeat( Nth(uss,          i), n ) )
    PushOnEnd( trialResponses,    Repeat( Nth(responses,    i), n ) )
    PushOnEnd( trialMaxResponses, Repeat( Nth(maxResponses, i), n ) )
  }
  trialStimuli      <- Flatten( trialStimuli ) # Nesting is undesired
  trialRewards      <- Flatten( trialRewards )
  trialUSs          <- Flatten( trialUSs )
  trialResponses    <- Flatten( trialResponses )
  trialMaxResponses <- Flatten( trialMaxResponses )
  trialOrder <- Shuffle( Sequence(1, Length(trialStimuli), 1) )

  ## Now we are ready to run all trials:
  maxTrial <- Length( trialStimuli )
  trial    <- 1
  while( trial <= maxTrial ) {
    ## Get stimulus and RewardPr for this trial:
    thisTrial    <- Nth(trialOrder, trial)
    stimulus     <- Nth( trialStimuli, thisTrial )
    rewardPr     <- ToNumber( Nth( trialRewards, thisTrial ) )
    uss          <- Nth( trialUSs, thisTrial )
    response     <- Nth( trialResponses, thisTrial )
    maxResponses <- ToNumber( Nth( trialMaxResponses, thisTrial ) )
    if( maxResponses <= 0 ) {
      maxResponses <- 1
    }
    ## Run trial and get response times and rewards collected
    RunTrial( phaseName, trial, stimulus, rewardPr, uss, response, 
              maxResponses )
    ## Wait an inter-trial interval and advance to next trial: 
    minITI <- ToNumber( Parameter("MinITI") )
    maxITI <- ToNumber( Parameter("MinITI") )
    Wait( minITI + ( maxITI - minITI )*Random() )
    trial <- trial + 1
  }
}

# Print a list to file in CSF format
define FilePrintCSV( file, data ) {
  n <- Length(data)
  if( n==1 ) {
    FilePrint_( file, Nth(data,1) )
  } else {
    front <- Subset( data, Sequence(1,n-1,1) )
    loop( d, front ) {
      if( FindInString( ToString(d), ",", 0) ) {
    d <- gQuote + d + gQuote 
  }
        FilePrint_( file, d + "," )
    }
    last <- Last(data)
    if( FindInString( ToString(last), ",", 0) ) {
      last <- gQuote + last + gQuote 
    }
    FilePrint( file, last )
  }
}

# Helper function to identify characteristics of stimuli. Given a
# stimulusName and a field, consults the Stimulus.csv information
# (stored in gStimulusInfo, with header in gStimulusHeader), and
# returns the value of that field for that stimulus. If nothing is
# found, the global parameters are consulted. If nothing is found
# there, Parameter() returns "NA", which ends up being our return
# value.
define LookupStimulus( sName, field ) {
  nStim <- Length( gStimNames )
  sIndex <- Lookup( sName, gStimNames, Sequence(1,nStim,1) )
  if( IsList(sIndex) ) {
    Message( "Cannot look up '"+field+"' for undefined stimulus "+sName, 1 )
  }  
  nFields <- Length( gStimulusHeader )
  fIndex <- Lookup(field, gStimulusHeader, Sequence(1,nFields,1) )
  if( IsList(fIndex) ) { # Did not find field, try global parameters
    result <- Parameter( field )
  } else {
    result <- Nth( Nth( gStimulusInfo, sIndex ), fIndex )
    if( not StringLength(result) ) { # Empty field, try global parameters
      result <- Parameter( field )
    }
  }
  return result
}

# Resolve the value in a stimulus field expressed in :/* syntax. If
# the value starts with :, the rest is expected to be a stimulus name,
# and the value of the field for that stimulus named is
# substituted. If the value start with *, we look up in the subject
# information for a field of the form 'value+field', and we substitute
# that value (here 'value' is stripped of the initial *). NOTE:
# Because 'value' can be multiple things separated by '+', we split it
# and return a list of resolved values (even if there is just one, for
# consistency).
define Resolve( field, value ) {
  results <- []
  loop( v, SplitString( value, "+" ) ) {
    if( SubString(v,1,1) == ":" ) {
      # This is the stimulus to be looked up:
      s <- SubString( v, 2, StringLength(v)-1 )
      PushOnEnd( results, LookupStimulus( s, field ) )
    } elseif( Substring(v,1,1) == "*" ) {
      s <- SubString( v, 2, StringLength(v)-1 )
      r <- Lookup( s+field,gSubjectHeader,gSubjectInfo )
      if( IsList(r) ) { # Nothing found
        Message( "Cannot find "+s+field+" in Groups.csv", 1 )
      } 
      PushOnEnd( results, r )
    } else {
      PushOnEnd( results, v )
    }
  }
  return results
}

# Interpret a 'color' string from Stimulus.csv, and return the
# corresponding PEBL Color object. Read through to see how colors can
# be specified 
define MakeColorRGBString( color ) {
  ## We see whether color is a name or RGB triplet, and act
  ## accordingly:
  components <- SplitString( color, "," )
  if( Length(components) != 3 ) { ## treat as color name
    c <- MakeColor( color )
  } else {
    cred <- ToNumber( Nth(components, 1) )
    cgreen <- ToNumber( Nth(components, 2) )
    cblue <- ToNumber( Nth(components, 3) )
    c <- MakeColorRGB( cred, cgreen, cblue )
  }
  return c
}

define Message( text, fatal ) {
  box <- MakeTextBox( text + " (Press space to quit)", 
    gFont, .9*gVideoWidth, .9*gVideoHeight )
  AddObject( box, gWindow )
  Move( box, .05*gVideoWidth, .05*gVideoHeight )
  Draw()
  WaitForKeyDown(" ")
  RemoveObject( box, gWindow )
  Draw()
  if( fatal ) {
    SignalFatalError( "alex: " + text )
  }
}

########################################################################
#                                                                      #
# In this section we have functions reading files in the Design        #
# directory to configure the experiment, and a few accessory functions #
#                                                                      #
########################################################################

## The two next functions implement a simple file locking mechanism

define LockFile( file ) {
  while( FileExists( file + ".lck" ) ) {
    Wait( 250 )
  }
  FileOpenOverWrite( file + ".lck" ) 
}

define UnlockFile( file ) {
  if( FileExists( file + ".lck" ) ) {
    DeleteFile( file + ".lck" )
  }
}

define ReadSubject() {
  subjectsFile <- gWD + "Design/Groups.csv"
  LockFile( subjectsFile )
  subjects <- ReadCSV( subjectsFile )
  gSubjectHeader <- Nth( subjects, 1 )
  SetElement( gSubjectHeader, 2, "Subject")
  found <- 0
  ## From a random group, pick a subject that has not yet been run
  loop( e, Shuffle( Rest(subjects) ) ) {
    loop( s, Sequence(1, ToNumber(Nth(e,2)), 1) ) {
      dataFilename <- gWD + "Data/" + Nth(e,1) + "-" + s + ".dat"
      if( not FileExists(dataFilename) ) {
        found <- 1
        SetElement( e, 2, s )
        break
      }
    }
    if( found ) {
      break
    }
  }
  ## Open data file before releasing lock, to prevent race conditions
  if( found ) {
    gSubjectInfo <- e
    gDataFile <- FileOpenWrite( dataFilename )
    UnlockFile( subjectsFile )
  } else {
    UnlockFile( subjectsFile )
    Message( "It looks like all subjects have been run!", 1 )
  }
}

define ReadStimuli() {
  csv <- ReadCSV( gWD + "Design/Stimuli.csv" )
  gStimulusHeader <- First( csv )
  gStimulusInfo <- Rest( csv )
  gStimNames <- []
  gStimTypes <- []
  gStimParams <- []
  gStimColors <- []
  gStimXOffsets <- []
  gStimYOffsets <- []
  loop( s, gStimulusInfo ) {
    PushOnEnd( gStimNames, Nth( s, 1 ) )
    PushOnEnd( gStimTypes, Nth( s, 2 ) )
    PushOnEnd( gStimParams, Nth( s, 3 ) )
    PushOnEnd( gStimColors, Nth( s, 4 ) )
    PushOnEnd( gStimXOffsets, Nth( s, 5 ) )
    PushOnEnd( gStimYOffsets, Nth( s, 6 ) )
  }
  ## Check there are no duplicate stimulus names
  if( Length(gStimNames) != Length( Levels(gStimNames) ) ) {
    Message("Duplicate in stimulus names: "+gStimNames, 1)
  }
  ## Now we are ready to create the stimulus objects
  gStimuli <- []
  n <- Length( gStimNames )
  loop( i, Sequence(1,n,1) ) {
    type <- Nth( gStimTypes, i )
    if( StringLength( Nth( gStimColors, i ) ) ) {
      ## Determine colors:
      colors <- Resolve( "Color", Nth(gStimColors, i) )
      c1name <- First( colors )
      if( StringLength(c1name) ) {
        c1 <- MakeColorRGBString( c1name )
      } else {
        c1 <- gColor
      }
      if( Length(colors) == 2 ) {
        c2name <- Rest( colors )
  if( StringLength( c2name ) ) {
    c2 <- MakeColorRGBString( c2name )
        } else {
          c2 <- gBackgroundColor
        }
      } else {
        c2 <- gBackgroundColor
      }    
    } else {
      c1 <- gColor
      c2 <- gBackgroundColor
    }
    ## Create a font for text stimuli    
    font <- MakeFont( Parameter("FontName")+".ttf", 0, 
                      ToNumber(Parameter("FontSize")), c1, c2, 1 )
    x <- ToNumber( First(Resolve( "XOffset", Nth( gStimXOffsets, i ) )) )
    y <- ToNumber( First(Resolve( "YOffset", Nth( gStimYOffsets, i ) )) )
    x <- x + gVideoWidth/2
    y <- y + gVideoHeight/2
    if(  type == "circle" ) {
      r <- ToNumber( First(Resolve( "Parameters", Nth(gStimParams,i) )) )
      s <- Circle( x, y, r, c1, 1 )
    } elseif( type == "square" ) {
      l <- ToNumber( First(Resolve( "Parameters", Nth(gStimParams,i) )) )
      s <- Square( x, y, l, c1, 1 )
    } elseif( type == "image" ) {
      p <- Resolve( "Parameters", Nth(gStimParams,i) )
      file <- First( p )
      if( Length(p) == 2 ) { # Optional 2nd parameter is zoom factor
  zoom <- ToNumber( Nth( p, 2 ) )
      } else {
  zoom <- 1
      }
      # We look up the file in 4 dirs: this experiment's Materials,
      # the system-wide Materials, PEBL's image files, and the current
      # directory (the latter is undocumented, that's just how PEBL's
      # MakeImage works).
      fileLocal <- gWD + "Materials/" + file
      fileAlex <- gAlexDir + file
      if( FileExists( fileLocal ) ) {
        s <- MakeImage( fileLocal )
      } elseif( FileExists( fileAlex ) ) {
        s <- MakeImage( fileAlex )
      } elseif( FileExists( file ) ) {
        s <- MakeImage( file )
      } else {
        Message( "Cannot find image file " + file, 1 )
      }
      s.ZOOMX <- zoom
      s.ZOOMY <- zoom
      Move( s, x, y )
   } elseif( type == "text" ) {
      w <- First( Resolve( "Parameters", Nth(gStimParams,i) ) )
      s <- MakeLabel( w, font )
      Move( s, x, y )
    } elseif( type == "textfile" ) {
      fileName <- First( Resolve( "Parameters", Nth(gStimParams,i) ) )
      text <- FileReadText( gWD + "Materials/" + fileName )
      s <- MakeTextBox( text, font, .9*gVideoWidth, .9*gVideoHeight )
      Move( s, .05*gVideoWidth, .05*gVideoHeight )
    } elseif( type == "sound" ) {
       f <- First( Resolve( "Parameters", Nth(gStimParams,i) ) )
       s <- LoadSound( gWD + "Materials/" + f )
    } else {
       Message( "Unsupported stimulus type: "+type, 1 )
    }
    PushOnEnd( gStimuli, s )
    AddObject( s, gWindow )
    Hide( s )
  }
}

define ReadPhases() {
  csv <- ReadCSV( gWD + "Design/Phases.csv" )
  gPhaseHeader <- First( csv )
  gPhases <- Transpose( Rest( csv ) )
}

define ReadParameters() {
  csv <- Transpose( Rest( ReadCSV( gWD + "Design/Parameters.csv" ) ) )
  gParameterNames <- Nth(csv, 1)
  gParameterValues <- Nth(csv, 2)
}

define Parameter( name ) {
  value <- Lookup( name, gParameterNames, gParameterValues )
  If( IsList(value) ) {
    value <- "NA"
  }
  return value
}