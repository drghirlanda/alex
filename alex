#!/usr/local/bin/pebl-language --fullscreen

define Start( par ) {

  ## This list is used to schedule stimulus onset and offset, see the
  ## section on timers below
  gTimers <- []

  # Have we been asked to run in a directory other than .?
  gWD <- Nth(par, 1)
  if( gWD != 0 ) {
    gWD <- gWD + "/"
    if( not IsDirectory( gWD ) ) {
      message <- "Command line argument "+gWD+" is not a folder"
      SignalFatalError( message )
    }
  } else {
    gWD <- ""
  }

  # Create data and log directories if not there
  if( not IsDirectory( gWD + "Data" ) ) {
    MakeDirectory( gWD + "Data" )
  }
  if( not IsDirectory( gWD + "Logs" ) ) {
    MakeDirectory( gWD + "Logs" )
  }

  # Read global parameters: (MUST be before ReadSubject to initialize
  # gFont which may be needed to create a message re: all subjects
  # having been run)
  ReadParameters()

  ## This is the folder where we look for support files. In contrast
  ## to alex-init, we might not need these files, so not finding
  ## anything is not an error. We look through a number of likely
  ## system directories anyway, stopping as soon as we find one.
  gAlexDir <- "Library/Materials/"
  dirs <- [ "",                       # Current folder takes precedence
            "/usr/share/alex/",       # Linux
            "/usr/local/share/alex/", # OS X
            "C:\Program Files\alex\\"  # Windows
          ]
  loop( d, dirs ) {
    if( IsDirectory( d + gAlexDir ) ) {
      gAlexDir <- d + gAlexDir
      break
    }
  }

  ## Initialize basic display elements:
  fg <- Parameter( "ForegroundColor" )
  if( fg == "NA" ) {
    fg <- "white"
  }
  bg <- Parameter( "BackgroundColor" )
  if( bg == "NA" ) {
    bg <- "black"
  }
  gWindow <- MakeWindow( bg )
  gBackgroundColor <- MakeColor( bg )
  gColor <- MakeColor( fg )
  fontname <- Parameter("FontName")
  if( fontname == "NA" ) {
    fontname <- "Vera"
  }
  fontsize <- Parameter("FontSize")
  if( fontsize == "NA" ) {
    fontsize <- 24
  }
  gFont <- MakeFont( fontname+".ttf", 0, 
    ToInteger(ToNumber(fontsize)), gColor, gBackgroundColor, 1 )

  ## Read other Design files. These must come after the basic
  ## initializations above to be able to display error messages if
  ## needed.
  ReadSubject()
  ReadPhases()     
  ReadStimuli()    

  # We can use logging only after ReadSubject() and ReadParameters():
  MyLog( "Start: found alex folder in '" + gAlexDir + "'" )
  MyLog( "Start: set working directory to '" + gWD + "'" ) 
  # Log parameter, phases, and stimuli:
  MyLog( "Start: using these parameters:" )
  loop( i, Sequence(1,Length(gParameterNames),1) ) {
    MyLog( "  "+Nth(gParameterNames,i)+" = "+Nth(gParameterValues,i) ) 
  }
  MyLog( "Start: using these phases:" )
  loop( phase, gPhases  ) {
    MyLog( "  "+ Flatten(phase) )
  }
  MyLog( "Start: using these stimuli:" )
  loop( s, gStimulusInfo ) {
    MyLog( "  " + s )
  }

  # Get hostname for recording data lines
  hostxt <- gWD + "Data/hostname.txt"
  LockFile( hostxt )
  SystemCall( "hostname > "+hostxt )
  hostream <- FileOpenRead( hostxt )
  gHostname <- FileReadLine( hostream )
  FileClose( hostream )
  DeleteFile( hostxt )
  UnlockFile( hostxt )
  MyLog( "Start: determined hostname as '"+gHostname+"'" )
  
  askID <- Parameter("AskID")
  if( askID != "NA" and ToNumber(askID) == 1 ) {
    gID <- GetEasyInput( "Please enter participant id, "+
      "then press enter:", gWindow )
    gID <- ToInteger( gID )
  } else {
    gID <- "NA"
  }

  askSex <- Parameter("AskSex")
  if( askSex != "NA" and ToNumber(askSex) == 1 ) {
    gSex <- GetEasyChoice( "Please select your sex", 
       ["Male", "Female", "Decline to answer"], ["M", "F", "D"], gWindow )
  } else {
    gSex <- "NA"
  }

  askAge <- Parameter("AskAge")
  if( askAge != "NA" and ToNumber(askAge) == 1 ) {
    gAge <- GetEasyInput( "Please enter your age in years, "+
      "then press enter:", gWindow )
    gAge <- ToInteger( gAge )
  } else {
    gAge <- "NA"
  }

  askRace <- Parameter("AskRace")
  if( askRace != "NA" and ToNumber(askRace) == 1 ) {
    raceNIH <- ["American Indian or Alaska Native", "Asian", "Black or African American", 
                 "Hispanic or Latino", "Native Hawaiian or other Pacific Islander", 
                 "White", "Other", "Decline to answer"]
    raceCodes <- ["AIAN", "A", "BAA", "HL", "NHPI", "W", "O", "NA"]
    gRace <- GetEasyChoice( "Please select your race or ethnicity",
      raceNIH, raceCodes, gWindow )
  } else {
    gRace <- "NA"
  }

  ShowCursor( 0 )
  Draw()

  ## Create a global list of valid response keys
  gKeys <- []
  kc <- [8,9,12,13,27]
  PushOnEnd( kc, Sequence(32,64,1) )
  PushOnEnd( kc, Sequence(91,127,1) )
  PushOnEnd( kc, Sequence(256,310,1) )
  loop( c, Flatten(kc) ) {
    PushOnEnd( gKeys, TranslateKeyCode(c) )
  }
  MyLog( "Start: accepting these response keys: " + gKeys ) 

  ## Print data file header. gDataFile has been opened by
  ## ReadSubject() to avoid race conditions with acquiring and
  ## releasing the lock to Groups.csv. We first print the hostname,
  ## followed by whatever fields are defined in Groups.csv (stored in
  ## gSubjectHeader), then fields for other data:
  FilePrintCSV( gDataFile, Flatten( ["Hostname",gSubjectHeader, 
    "ID","Sex","Age","Race","Time","Phase","Trial","S1","S1Duration","S1On",
    "S2","S2Duration","S2On","S2Prob","Response","RT","S2Pres","Key"] ) )

  ## Run experimental phases. We loop through all elements of the
  ## Phase column in Phases.csv. Phase p is run with RunPhase( p ),
  ## and we keep track of the phases already run in the alreadyRun
  ## list. The reason is that each phase name appears multiple times
  ## in the Phase column when the phase features multiple
  ## stimuli. RunPhase() looks for all stimuli pertaining to a phase,
  ## so we have to call it only once per phase.
  alreadyRun <- []
  loop( p, Lookup("Phase",gPhaseHeader,gPhases)  ){
    if( not Sum( Match( alreadyRun, p ) ) ) {
      RunPhase( p )
      PushOnEnd( alreadyRun, p )
    }
  }

  FileClose( gDataFile )
  if( gLogging == 1 ) {
    FileClose( gLogFile)
  }
  ShowCursor( 1 )
}


########################################################################
#                                                                      #
# This section contains the functions that read files in the Design    #
# directory in order to configure the experiment.                      #
#                                                                      #
########################################################################

define ReadSubject() {
  subjectsFile <- gWD + "Design/Groups.csv"
  LockFile( subjectsFile )
  subjects <- ReadCSV( subjectsFile )
  gSubjectHeader <- Nth( subjects, 1 )
  SetElement( gSubjectHeader, 2, "Subject" )
  found <- 0
  ## From a random group, pick a subject that has not yet been run
  loop( e, Shuffle( Rest(subjects) ) ) {
    loop( s, Sequence(1, ToNumber(Nth(e,2)), 1) ) {
      dataFilename <- gWD + "Data/" + Nth(e,1) + "-" + s + ".csv"
      if( not FileExists(dataFilename) ) {
        found <- 1
        SetElement( e, 2, s )
        break
      }
    }
    if( found ) {
      break
    }
  }

  ## Set up log file (before potential Messages)
  gLogging <- ToNumber( Parameter("Log") )
  if( gLogging == 1 ) {  
    logFilename <- gWD + "Logs/" + Nth(e,1) + "-" + s + ".log"
    gLogFile <- FileOpenWrite( logFilename )
  }

  ## Open data file before releasing lock, to prevent race conditions
  if( found ) {
    gSubjectInfo <- e
    gDataFile <- FileOpenWrite( dataFilename )
    UnlockFile( subjectsFile )
  } else {
    UnlockFile( subjectsFile )
    Message( "It looks like all subjects have been run!", 1 )
  }

  ## This is at the end because Message uses logging:
  Message( "Running subject "+Nth(gSubjectInfo,2)+" in group "+Nth(gSubjectInfo,1), 0 )
}

define ReadStimuli() {
  filename <- gWD + "Design/Stimuli.csv"   
  csv <- ReadCSV( filename )
  gStimulusHeader <- First( csv )
  gStimulusInfo <- Rest( csv )
  gStimNames <- []
  gStimTypes <- []
  gStimParams <- []
  gStimColors <- []
  gStimXOffsets <- []
  gStimYOffsets <- []
  loop( s, gStimulusInfo ) {
    PushOnEnd( gStimNames, Nth( s, 1 ) )
    PushOnEnd( gStimTypes, Nth( s, 2 ) )
    PushOnEnd( gStimParams, Nth( s, 3 ) )
    PushOnEnd( gStimColors, Nth( s, 4 ) )
    PushOnEnd( gStimXOffsets, Nth( s, 5 ) )
    PushOnEnd( gStimYOffsets, Nth( s, 6 ) )
  }
  ## Check there are no duplicate stimulus names
  if( Length(gStimNames) != Length( Levels(gStimNames) ) ) {
    Message("Duplicate in stimulus names: "+gStimNames, 1)
  }
  ## Now we are ready to create the stimulus objects
  gStimuli <- []
  n <- Length( gStimNames )
  loop( i, Sequence(1,n,1) ) {
    stimulus <- Nth( gStimNames, i )
    type <- Nth( gStimTypes, i )
    if( StringLength( Nth( gStimColors, i ) ) ) {
      ## Determine colors:
      colors <- Resolve( stimulus, "Color", Nth(gStimColors, i) )
      c1name <- First( colors )
      if( StringLength(c1name) ) {
        c1 <- MakeColorRGBString( c1name )
      } else {
        c1 <- gColor
      }
      if( Length(colors) == 2 ) {
        c2name <- Rest( colors )
        if( StringLength( c2name ) ) {
          c2 <- MakeColorRGBString( c2name )
        } else {
          c2 <- gBackgroundColor
        }
      } else {
        c2 <- gBackgroundColor
      }    
    } else {
      c1 <- gColor
      c2 <- gBackgroundColor
    }
    ## Create a font for text stimuli    
    font <- MakeFont( Parameter("FontName")+".ttf", 0, 
                      ToNumber(Parameter("FontSize")), c1, c2, 1 )
    x <- ToNumber( First(Resolve(stimulus,"XOffset",Nth(gStimXOffsets, i))) )
    y <- ToNumber( First(Resolve(stimulus,"YOffset",Nth(gStimYOffsets, i))) )
    x <- x + gVideoWidth/2
    y <- y + gVideoHeight/2
    if(  type == "circle" ) {
      r <- ToNumber( First(Resolve(stimulus,"Parameters",Nth(gStimParams,i))) )
      s <- Circle( x, y, r, c1, 1 )
    } elseif( type == "square" ) {
      l <- ToNumber( First(Resolve(stimulus,"Parameters",Nth(gStimParams,i))) )
      s <- Square( x, y, l, c1, 1 )
    } elseif( type == "image" ) {
      p <- Resolve( stimulus, "Parameters", Nth(gStimParams,i) )
      file <- First( p )
      if( Length(p) == 2 ) { # Optional 2nd parameter is zoom factor
        zoom <- ToNumber( Nth( p, 2 ) )
      } else {
        zoom <- 1
      }
      # We look up the file in 4 dirs: this experiment's Materials,
      # the system-wide Materials, PEBL's image files, and the current
      # directory (the latter is undocumented, that's just how PEBL's
      # MakeImage works).
      fileLocal <- gWD + "Materials/" + file
      fileAlex <- gAlexDir + file
      if( FileExists( fileLocal ) ) {
        s <- MakeImage( fileLocal )
      } elseif( FileExists( fileAlex ) ) {
        s <- MakeImage( fileAlex )
      } elseif( FileExists( file ) ) {
        s <- MakeImage( file )
      } else {
        Message( "Cannot find image file " + file, 1 )
      }
      s.ZOOMX <- zoom
      s.ZOOMY <- zoom
      Move( s, x, y )
   } elseif( type == "text" ) {
      w <- First( Resolve( stimulus, "Parameters", Nth(gStimParams,i) ) )
      s <- MakeLabel( w, font )
      Move( s, x, y )
    } elseif( type == "textfile" ) {
      fileName <- First( Resolve( stimulus, "Parameters", Nth(gStimParams,i) ) )
      fileName <- gWD + "Materials/" + fileName
      if( not FileExists( fileName ) ) {
        Message( "Cannot find file: "+fileName, 1 )
      }
      text <- FileReadText( fileName )
      s <- MakeTextBox( text, font, .9*gVideoWidth, .9*gVideoHeight )
      Move( s, .05*gVideoWidth, .05*gVideoHeight )
    } elseif( type == "sound" ) {
       fileName <- First( Resolve(stimulus, "Parameters", Nth(gStimParams,i)) )
       dirfileName <- gWD + "Materials/" + fileName
       if( FileExists( dirfileName ) ) {
         s <- LoadSound( dirfilename )
       } else { # Attempt to load PEBL-provided audio file
         s <- LoadSound( fileName )
       }
    } else {
       Message( "Unsupported stimulus type: "+type, 1 )
    }
    PushOnEnd( gStimuli, s )
    if( type != "sound" ) { # Sounds don't have to be added to the screen 
      AddObject( s, gWindow )
      Hide( s )
    }
  }
}

define ReadPhases() {
  filename <- gWD + "Design/Phases.csv"
  csv <- ReadCSV( filename )
  gPhaseHeader <- First( csv )
  gPhases <- Rest( csv )
  ## Resolve * and : notation:
  nPhaseStimuli <- Length( gPhases )
  loop( i, Sequence(1, nPhaseStimuli, 1) ) {
    phaseStimulusInfo <- Nth( gPhases, i )
    phase <- Lookup( "Phase", gPhaseHeader, phaseStimulusInfo )
    stimulus <- Lookup( "S1", gPhaseHeader, phaseStimulusInfo )
    numFields <- Length( gPhaseHeader )
    loop( j, Sequence(1, numFields, 1) ) {
      field <- Nth( gPhaseHeader, j ) 
      value <- Nth( phaseStimulusInfo, j ) 
      if( field != "Phase" and field != "S1" ) {
        newvalue <- ResolvePhase( phase, stimulus, field, value )
        SetElement(phaseStimulusInfo, j, newvalue )
      }
    }
  }
  gPhases <- Transpose( gPhases )
}

define ReadParameters() {
  filename <- gWD + "Design/Parameters.csv"
  csv <- Transpose( Rest( ReadCSV( filename ) ) )
  gParameterNames <- Nth(csv, 1)
  gParameterValues <- Nth(csv, 2)
}


########################################################################
#                                                                      #
# The following two functions set the experiment in motion, with       #
# RunPhase responsible for coordinating trials within a phase, and     #
# RunTrial for coordinating the events within a single trial.          #
#                                                                      #
########################################################################

define RunPhase( phaseName ) {
  MyLog( "RunPhase: starting phase "+phaseName )
  DisplayBackground( phaseName )

  # Get stimulus settings for this phase. Each line in Phases.csv
  # contains a stimulus entry for a specific phase. Using
  # LookupPhase() we look up which stimuli enter this phase:
  stimuli      <- LookupPhase(phaseName, "S1")
  numTrials    <- LookupPhase(phaseName, "Trials")
  rewards      <- LookupPhase(phaseName, "S2Prob")
  uss          <- LookupPhase(phaseName, "S2")
  responses    <- LookupPhase(phaseName, "Response")
  maxResponses <- LookupPhase(phaseName, "MaxResponses")
  maxInvalid   <- LookupPhase(phaseName, "MaxInvalid")

  ## We build lists trialStimuli and trialRewards to contain stimuli
  ## and rewards repeated as many times as given in 'trials'. The
  ## order of presentation is then randomized by picking stimuli from
  ## a shuffled list 'trialOrder', see end of block
  trialStimuli      <- []
  trialRewards      <- []
  trialUSs          <- []
  trialResponses    <- []
  trialMaxResponses <- []
  loop( i, Sequence( 1, Length(stimuli), 1 ) ) {
    n <- ToNumber( Nth(numTrials, i) )
    s <- Nth(stimuli, i )
    MyLog( "RunPhase: scheduling "+n+" trials with stimulus "+s )
    PushOnEnd( trialStimuli,      Repeat( s                   , n ) )
    PushOnEnd( trialRewards,      Repeat( Nth(rewards,      i), n ) )
    PushOnEnd( trialUSs,          Repeat( Nth(uss,          i), n ) )
    PushOnEnd( trialResponses,    Repeat( Nth(responses,    i), n ) )
    PushOnEnd( trialMaxResponses, Repeat( Nth(maxResponses, i), n ) )
  }
  trialStimuli      <- Flatten( trialStimuli ) # Nesting is undesired
  trialRewards      <- Flatten( trialRewards )
  trialUSs          <- Flatten( trialUSs )
  trialResponses    <- Flatten( trialResponses )
  trialMaxResponses <- Flatten( trialMaxResponses )
  MyLog( "RunPhase: constructed trial list: " + trialStimuli )

  ## We define a random order for the trials, taking into account that
  ## the number of trials could be zero (in some experimental designs
  ## some phases might be excluded for some groups of subjects).
  if( Length(trialStimuli) ) {
    trialOrder <- Shuffle( Sequence(1, Length(trialStimuli), 1) )
  } else {
    trialOrder <- []
  }
  MyLog( "RunPhase: constructed trial order: " + trialOrder )

  ## Now we are ready to run all trials:
  maxTrial <- Length( trialStimuli )
  trial    <- 1
  while( trial <= maxTrial ) {
    ## Get stimulus and RewardPr for this trial:
    thisTrial    <- Nth(trialOrder, trial)
    stimulus     <- Nth( trialStimuli, thisTrial )
    rewardPr     <- ToNumber( Nth( trialRewards, thisTrial ) )
    uss          <- Nth( trialUSs, thisTrial )
    response     <- Nth( trialResponses, thisTrial )
    maxResponses <- ToNumber( Nth( trialMaxResponses, thisTrial ) )
    if( maxResponses <= 0 ) {
      maxResponses <- 1
    }
    ## Collect responses during pre-trial ITI:
    RunITI( phaseName, trial )
    ## Run trial and get response times and rewards collected:
    RunTrial( phaseName, trial, stimulus, rewardPr, uss, response, 
              maxResponses, maxInvalid )
    ## Advance to next trial
    trial <- trial + 1
  }
  UndisplayBackground( phaseName )
}

define RunTrial( phase, trial, s1, rewardProb, s2, response,
                 maxResponses, maxInvalid ) {
  MyLog( "RunTrial: starting trial: " + 
    [phase, trial, s1, rewardProb, s2, response, maxResponses ] )
  # No reward if S2 not defined:
  if( s2 == "NA" ) {
    rewardProb <- "NA"
  }
  s2Duration <- "NA" # Reset later if s2 scheduled 
  # Determine some parameters. In ToNumber conversions, NA becomes 0:
  s1s2Interval <- Parameter("S1S2Interval")
  if( s1s2Interval == "NA" ) {
    s1s2Interval <- 0
  } else {
    s1s2Interval <- ToNumber( s1s2Interval )
  }
  rtMin <- ToNumber( Parameter("ResponseTimeMin") )
  rtMax <- ToNumber( Parameter("ResponseTimeMax") )
  MyLog( "RunTrial: accepting responses between "+rtMin+" and "+rtMax )
  # Initialize some trial-level variables:
  validCount    <- 0
  invalidCount  <- 0
  times         <- SetTimer( GetTime(), s1 )
  startTime     <- Nth( times, 1 ) 
  endTime       <- Nth( times, 2 ) # could be longer, see next
  s1Duration    <- endtime - startTime
  # Now we handle the <classical> specification. If the trial is
  # 'classical', we decide whether to show S2 or not. If S2 is showed,
  # we lengthen trial duration accordingly
  if( response == "<classical>" ) {
    MyLog( "RunTrial: <classical> trial" )
    classical <- 1
    if( Random() < rewardProb ) {
      s2Pres <- "T"
      times <- SetTimer( endTime + s1s2Interval, s2 ) # Schedule S2
      endTime <- Nth(times, 2) # Lengthen trial
      s2Duration <- endTime - Nth(times, 1)
      MyLog( "RunTrial: lengthening classical trial to show S2 completely" )
    } else {
      s2Pres <- "F"
    }
  } else { # Instrumental trial
    MyLog( "RunTrial: instrumental trial" )
    classical <- 0
    s2Pres <- "F" # changed later if S2 schedulued
  }
  # This variable keeps track of whether an instrumental trial has
  # been lengthened or not because the US had to be shown near the end
  # of the trial. It is checked later on before deciding to lengthen a
  # trial, and it is set to zero upon lengthening a trial. (Note: that
  # code is only reached in instrumental trials.)
  notLengthened <- 1 
  # We are ready to run the trial loop. The trial continues until
  # either time runs out or we reach the maximum number of (valid)
  # responses. To break out of the loop in the latter case we use a
  # 'continue' variabel because PEBL does not have a break statement
  # for while loops (as of version 0.14).
  continue <- 1
  MyLog( "RunTrial: trial scheduled to end at "+endTime )
  while( GetTime() < endTime and continue ) {

    UpdateTimers()

    tNext <- NextTimer()
    if( tNext == "NA" ) { # Nothing scheduled
      tWait <- endTime - GetTime()
    } else { 
      tWait <- tNext - GetTime()
    }
    key <- WaitForListKeyPressWithTimeout( gKeys, tWait, 1 )
    if( key == " " ) { # Special notation for spacebar
      key <- "<space>"
    }
    if( IsList(key) ) {   # Keep in mind: the Wait...() timed out,
      key <- "<timeout>"  # but not necessarily the whole trial
      rt <- "NA"
    } else {
      rt <- GetTime() - startTime # Time since trial start
      # Next line figures out whether response is valid:
      if( rt>=rtMin and (rt<=rtMax or rtMax==0) and key==response ) {
        valid <- 1
        validCount <- validCount + 1
	MyLog( "RunTrial: valid response on key '"+key+"' at rt="+rt )
      } else {
        valid <- 0
	invalidCount <- invalidCount + 1
	MyLog( "RunTrial: invalid response on key '"+key+"' at rt="+rt )
        rt <- "NA"
      }
      if( (not classical) and valid ) { # Schedule S2 (possibly)
        if( Random() < rewardProb and key == response ) {
          s2Pres <- "T"
          if( TimerOn( s2 ) == "F" ) { # Schedule S2 if not already on
	    times <- SetTimer( GetTime() + s1s2Interval, s2 )
	    onTime <- Nth(times, 1)
	    offTime <- Nth(times, 2)
	    s2Duration <- offTime - onTime
	    # Lengthen trial if necessary, but only if it has not been
	    # lengthened already:
	    if( offTime > endTime and notLengthened ) {
              endTime <- offTime
	      notLengthened <- 0
	      MyLog( "RunTrial: lengthening instrumental trial to show S2 completely" )
	    }
          }
        }
      }
    }
    ## Save data line to file if there was a response, or if there was
    ## no response and the trial timed out (so that we have a record
    ## of what stimuli appeared in the trial)
    if( key=="<timeout>" and GetTime() >= endTime ) {
      trialTimeout <- 1
    } else {
      trialTimeout <- 0
    }
    totalResponses <- validCount + invalidCount
    if( key!="<timeout>" or (totalResponses==0 and trialTimeout) ) {
      FilePrintCSV( gDataFile, Flatten( [ gHostname, gSubjectInfo, 
        gID, gSex, gAge, gRace, GetTime(), phase, trial, s1, s1Duration,
        TimerOn(s1), s2, s2Duration, TimerOn(s2), rewardProb, 
        response, rt, s2Pres, key] ) )
	# "Hostname", gSubjectHeader, "ID", "Sex", "Age", "Race",
	# "Time", "Phase", "Trial", "S1", "S1Duration", "S1On", "S2",
	# "S2Duration", "S2On", "S2Prob", "Response", "RT", "S2Pres",
	# "Key"
    }

    ## We need to UpdateTimers() now so that the if block that comes
    ## next can check meaningfully whether s2 is on or not
    UpdateTimers()

    ## End trial if s2 is off and valid or invalid max responses reached
    if( (validCount >= maxResponses or invalidCount >= maxInvalid) and TimerOn(s2)=="F" ) {
      MyLog( "RunTrial: maximum responses reached: endindg trial" )
      MyLog( "          and expiring all timers" )
      ExpireTimers()
      continue <- 0
    }
  }
  ExpireTimers() # Turn off everything
  MyLog( "RunTrial: trial completed" )
}

## This is a simplified event loop that runs during ITIs, when by
## definition no events are scheduled
define RunITI( phaseName, trial ) {
  minITI <- ToNumber( Parameter("MinITI") )
  maxITI <- ToNumber( Parameter("MaxITI") )
  thisITI <- ( minITI + ( maxITI - minITI )*Random() )
  itiLeft <- thisITI
  startTime <- GetTime()
  itiResponses <- 0
  while( itiLeft > 1 ) {
    key <- WaitForListKeyPressWithTimeout( gKeys, itiLeft, 1 )
    if( key == " " ) {
      key <- "<space>"
    }
    rt <- GetTime() - startTime
    itiLeft <- thisITI - rt
    ## Save data line for stimulus "ITI" with S2 details = "NA"
    if( not IsList(key) ) {
      itiResponses <- itiResponses + 1
      FilePrintCSV( gDataFile, Flatten( [ gHostname, gSubjectInfo, 
        gID, gSex, gAge, gRace, GetTime(), phaseName, trial, "ITI", thisITI, 
        "T", "NA", "NA", "F", "NA", "NA", rt, "F", key] ) )
    }
  }
  ## Save a single ITI data line if no responses during ITI:  
  if( itiResponses == 0 ) {
    FilePrintCSV( gDataFile, Flatten( [ gHostname, gSubjectInfo, 
      gID, gSex, gAge, gRace, GetTime(), phaseName, trial, "ITI", thisITI, "T",
      "NA", "NA", "F", "NA", "NA", "NA", "F", "<timeout>"] ) ) 
  }
}

########################################################################
#                                                                      #
# The next set are lookup functions that access phase, stimulus, and   #
# parameter information as necessary during configuration and runtime. #
#                                                                      #
########################################################################

# Identifies what enters a phase. If we don't find a field in the
# phase header, we see whether it is defined as a global parameter
# (if that fails, we get NAs, which we return).
define LookupPhase( phaseName, field ) {
  fields <- Lookup( field, gPhaseHeader, gPhases )
  if( not Length( fields ) ) { 
    stimuli <- LookupPhase( phaseName, "S1" )
    result <- Repeat( Parameter( field ), Length( stimuli ) )
  } else {
    idx <- Match( Lookup( "Phase", gPhaseHeader, gPhases ), phaseName ) 
    tempResult <- Filter( fields, idx )
    result <- []
    loop( r, tempResult ) {
      if( not StringLength(r) ) {
        r <- Parameter( field )
      }
      PushOnEnd( result, r )
    }
  }
  return result
}

# Identifies characteristics of stimuli. Given a stimulus and a field,
# consults the Stimulus.csv information (stored in gStimulusInfo, with
# header in gStimulusHeader) and returns the value of the field for
# that stimulus. If nothing is found, the global parameters are
# consulted. If nothing is found there, Parameter() returns "NA",
# which ends up being our return value.
define LookupStimulus( sName, field ) {
  nStim <- Length( gStimNames )
  sIndex <- Lookup( sName, gStimNames, Sequence(1,nStim,1) )
  if( IsList(sIndex) ) {
    Message( "Cannot look up '"+field+"' for undefined stimulus "+sName, 1 )
  }  
  nFields <- Length( gStimulusHeader )
  fIndex <- Lookup(field, gStimulusHeader, Sequence(1,nFields,1) )
  if( IsList(fIndex) ) { # Did not find field, try global parameters
    result <- Parameter( field )
  } else {
    result <- Nth( Nth( gStimulusInfo, sIndex ), fIndex )
    if( not StringLength(result) ) { # Empty field, try global parameters
      result <- Parameter( field )
    }
  }
  return result
}

# Returns the value of a parameter given by name.
define Parameter( name ) {
  value <- Lookup( name, gParameterNames, gParameterValues )
  If( IsList(value) ) {
    value <- "NA"
  }
  return value
}

# Identifies stimuli designated as present for the duration of a phase.
define FindBackground( phaseName ) {
  backgroundList <- []
  loop( name, gStimNames ) {
    if( FindInString( name, "Background"+phaseName, 1 ) ) {
      PushOnEnd( backgroundList, name )
    }
  }
  if( Length( backgroundList ) ) {
    backgrounds <- First( backgroundList )
    loop( b, Rest( backgroundList ) ) {
      backgrounds <- backgrounds + "+" + b
    }
  } else {
    backgrounds <- ""
  }
  return backgrounds
}


########################################################################
#                                                                      #
# These functions parse stimulus and phase information according to    #
# special notation and return the resolved values.                     #
#                                                                      #
########################################################################

# Resolves the value in a stimulus field expressed in :/* syntax. If
# the value starts with :, the rest is expected to be a stimulus name,
# and the value of the field for the named stimulus is substituted.
# If the value starts with *, we look up in the subject information
# for a field of the form 'stimulus+field', and we return that value.
# NOTE: Because 'value' can be multiple things separated by '+',
# we split it and return a list of resolved values (even if there
# is just one, for consistency).
define Resolve( stimulus, field, value ) {
  results <- []
  loop( v, SplitString( value, "+" ) ) {
    if( SubString(v,1,1) == ":" ) {
      # This is the stimulus to be looked up:
      s <- SubString( v, 2, StringLength(v)-1 )
      v2 <- LookUpStimulus( s, field )
      # We are sure we are passing only one field to Resolve so we
      # take First to get rid of a nested list that would mess up the
      # returned data:
      r <- First( Resolve( s, field, v2 ) )
      PushOnEnd( results, r )
    } elseif( v == "*" ) {
      r <- Lookup( stimulus+field, gSubjectHeader, gSubjectInfo )
      if( IsList(r) ) { # Nothing found
        Message( "Cannot find "+stimulus+field+" in Groups.csv", 1 )
      } 
      PushOnEnd( results, r )
    } else {
      PushOnEnd( results, v )
    }
  }
  MyLog( "Resolve: mapped "+[stimulus, field, value]+" to "+results )
  return results
}

# Similar to Resolve(), but for phases. Does not support + notation,
# only : and *.
define ResolvePhase( phase, stimulus, field, value ) {
  if( SubString( value, 1, 1 ) == ":" ) {
    Message( "Invalid notation for phase parameters (:)", 1 )
    # Under construction...
    # p <- SubString( value, 2, StringLength(value)-1 )
    # result <- ResolvePhase( p, stimulus, field, value )
    # MyLog( "ResolvePhase: resolved '"+value+"' to '"+result+"'" )
  } elseif( value == "*" ) {
    result <- Lookup( phase+stimulus+field, gSubjectHeader, gSubjectInfo )
    if( IsList(result) ) { # Nothing found
      Message( "Cannot find "+phase+stimulus+field+" in Groups.csv", 1 )
    } 
    MyLog( "ResolvePhase: resolved '"+value+"' to '"+result+"'" )
  } else {
    result <- value
  }
  return result
}

# Interprets a 'color' string from Stimulus.csv, and returns the
# corresponding PEBL Color object. Refer to manual for how colors can
# be specified.
define MakeColorRGBString( color ) {
  # We see whether color is a name or RGB triplet, and act accordingly:
  components <- SplitString( color, "-" )
  if( Length(components) != 3 ) { # treat as color name
    c <- MakeColor( color )
    MyLog( "MakeColorRGBString: creating color '"+color+"'" )
  } else {
    cred <- ToNumber( Nth(components, 1) )
    cgreen <- ToNumber( Nth(components, 2) )
    cblue <- ToNumber( Nth(components, 3) )
    MyLog( "MakeColorRGBString: creating color "+components )
    c <- MakeColorRGB( cred, cgreen, cblue )
  }
  return c
}


########################################################################
#                                                                      #
# Display and Undisplay are two utility functions that can show and    #
# hide multiple visual stimuli, and also start and pause the playback  #
# of audio stimuli. The next two do the same for background stimuli.   #
#                                                                      #
########################################################################

define Display( stimulus ) {
  # The 'stimulus' may actually be a compound, like "A+B", so we split
  # it into individual stimuli and then display each of them. We look
  # up the stimulus objects in the gStimuli list. NOTE: This is
  # actually used only for compound background stimuli, which are
  # untimed. For timed stimuli
  n <- Length( gStimNames )
  loop( stimName, SplitString(stimulus, "+") ) {
    i <- Lookup( stimName, gStimNames, Sequence(1,n,1) )
    if( IsList(i) ) {
      Message( "Cannot find stimulus: '" + stimName + "'", 1 )
    }
    s <- Nth( gStimuli, i )
    if( IsAudioOut(s) ) {
      Playbackground( s )
    } else {
      Show( s )
    }
  }
  Draw()
}

define Undisplay( stimulus ) {
  n <- Length( gStimNames )
  loop( stimName, SplitString(stimulus, "+") ) {
    i <- Lookup( stimName, gStimNames, Sequence(1,n,1) )
    s <- Nth( gStimuli, i )
    if( IsAudioOut(s) ) {
      Stop( s )
    } else {
      Hide( s )
    }
  }
  Draw()
}

define DisplayBackground( phaseName ) {
  bg <- FindBackground( phaseName )
  if( StringLength( bg ) ) {
    MyLog( "DisplayBackground: found "+bg+" as background" )
    Display( bg )
  } else {
    MyLog( "DisplayBackground: no background found" )
  }
}

define UndisplayBackground( phaseName ) {
  bg <- FindBackground( phaseName )
  if( StringLength( bg ) ) {
    Undisplay( bg )
  }
}


########################################################################
#                                                                      #
# These next functions manage timers, as described below.              #
#                                                                      #
########################################################################

## A timer is a list [ tOn, duration, stimulus, isOn ] where the first
## element is the time the stimulus is supposed to be turned on, and
## the second element is its duration. The fourth element is a flag
## that is 0 at the beginning and is set to 1 by UpdateTimers() when
## the stimulus is actually turned on. The list of existing timers is
## maintained in the gTimers variables created in Start().

# Creates a new timer. The tOn argument is the absolute start time
# (since when the program was started). The duration must be
# non-negative. The tOn argument is returned, which enables the
# construct StartTime( GetTime(), ... ) to avoid the ticker elapsing
# between the time tOn is calculated and the time tOn is actually used
# to create the timer structure.
#
# A timer's duration is figured out as follows. First we call
# LookupStimulus(). If this does not find anyting specific, it calls
# Parameter(). If this does not find anything, it returns "NA", which
# is returned back by LookupStimulus() to the Resolve() call wrapped
# around it. Sorry for the complication.
define SetTimer( tOn, stimulus ) {
  if( tOn < GetTime() ) {
    x <- stimulus+" start time is in the past: "+tOn
    MyLog( "SetTimer: " + x )
  }
  tOff <- tOn
  ## We loop over stimuli looking for Duration and Onset settings:
  loop( s, SplitString(stimulus,"+") ) {
    ## Figure out duration:
    dur <- First(Resolve( s, "Duration", LookUpStimulus(s,"Duration") ))
    if( dur == "NA" ) {
      MyLog( "SetTimer: no duration found for stimulus " + s )
      Message( "Could not determine duration of " + s, 1 )
    }
    dur <- ToNumber( dur )
    if( dur < 0 ) {
      MyLog( "SetTimer: negative duration found for stimulus " + s )
      Message( s + " has negative duration: " + dur, 1 )
    }
    ## Figure out onset:
    ons <- First(Resolve( s, "Onset", LookupStimulus(s,"Onset") ))
    ons <- ToNumber( ons ) # NA becomes 0, which is a valid onset
    ## Schedule timer:
    newTimer <- [ tOn + ons, dur, s, 0 ]
    PushOnEnd( gTimers, newTimer )
    MyLog( "SetTimer: new timer: " + newTimer )
    ## Update tOff if needed:
    if( tOn + ons + dur > tOff ) {
      tOff <- tOn + ons + dur
    }
  }
  return [tOn, tOff]
}

# Goes through all existing timers, turning on those that are due
# and turning off and removing from the list those that have expired.
define UpdateTimers() {
  expired <- [] # List of expired timers
  i <- 1
  while( i <= Length( gTimers ) ) {
    timer <- Nth( gTimers, i )
    tOn <- Nth( timer, 1 )
    duration <- Nth( timer, 2 )
    stimulus <- Nth( timer, 3 )
    isOn <- Nth( timer, 4 )
    t <- GetTime()
    if( t >= tOn and not isOn ) { # We need to turn this on
      Display( stimulus )
      SetElement( timer, 4, 1 ) # Mark timer as being on
      MyLog( "UpdateTimers: turning on timer: " + timer )
    } elseif( t >= tOn + duration ) {
      Undisplay( stimulus )
      PushOnEnd( expired, i ) 
      MyLog( "UpdateTimers: removing timer: " + timer )
    }
    i <- i + 1
  }
  Draw()
  gTimers <- RemoveSubset( gTimers, expired ) 
}

# Undisplays all stimuli and cancels all timers.
define ExpireTimers() {
  loop( timer, gTimers ) {
    Undisplay( Nth( timer, 3 ) )
    MyLog( "ExpireTimers: expired "+timer )
  }
  Draw()
  gTimers <- []
}

# Returns T if a stimulus is currently displayed, F otherwise. We have
# to take care of the fact that 'stimulus' may be a compound, one or
# more parts of which may be displayed.
define TimerOn( stimulus ) {
  result <- "F"
  components <- SplitString( stimulus, "+" )
  loop( timer, gTimers ) {
    loop( s, components ) {
      if( Nth(timer, 3) == s and Nth(timer, 4) ) {
        result <- "T"
        break
      }
    }
    if( result == "T" ) {
      break
    }
  }
  return result        
}

# Goes through all timers and returns the time of the next event,
# i.e., the next time a stimulus has to be turned either on or off.
# Used when deciding how long to wait for responses in RunTrial.
define NextTimer() {
  tMagic <- 123456789
  tMin <- tMagic
  loop( timer, gTimers ) {
    tOn <- Nth( timer, 1 )
    tOff <- tOn + Nth( timer, 2 )
    if( tOn > GetTime() and tOn < tMin ) {
      tMin <- tOn
    } elseif( tOff < tMin ) {
      tMin <- tOff
    }
  }
  if( tMin == tMagic ) {
     tMin <- "NA"
  }
  MyLog( "NextTimer: next event: "+tMin )  
  return tMin
}


########################################################################
#                                                                      #
# The two next functions implement a simple file locking mechanism.    #
#                                                                      #
########################################################################

define LockFile( file ) {
  unsafe <- 1
  while( unsafe ) {
    while( FileExists( file + ".lck" ) ) {
      Print( "LockFile: waiting for lock on "+file+" to be released" )
      Wait( 50 )
    }
    stream <- FileOpenOverWrite( file + ".lck" ) 
    check <- RandomDiscrete(999) +"."+ RandomDiscrete(999)
    FilePrint( stream, check )
    FileClose( stream )
    Wait( 500 ) # This should be enough to wait for others...
    stream <- FileOpenRead( file + ".lck" )
    check2 <- ToNumber( FileReadWord( stream ) )
    FileClose( stream )
    if( ToNumber(check) == check2 ) {
      unsafe <- 0
      Print( "LockFile: acquired lock on "+file )
    }
  }
}

define UnlockFile( file ) {
  if( FileExists( file + ".lck" ) ) {
    DeleteFile( file + ".lck" )
  }
  Print( "LockFile: released lock on "+file )
}


########################################################################
#                                                                      #
# These functions are responsible for recording data, logging          #
# information, and printing error messages to screen.                  #
#                                                                      #
########################################################################

# Print a list to file in CSF format
define FilePrintCSV( file, data ) {
  n <- Length(data)
  if( n==1 ) {
    FilePrint_( file, Nth(data,1) )
  } else {
    front <- Subset( data, Sequence(1,n-1,1) )
    loop( d, front ) {
      if( FindInString( ToString(d), ",", 0) ) {
    d <- gQuote + d + gQuote 
  }
        FilePrint_( file, d + "," )
    }
    last <- Last(data)
    if( FindInString( ToString(last), ",", 0) ) {
      last <- gQuote + last + gQuote 
    }
    FilePrint( file, last )
  }
}

define MyLog( logline ) {
  if( gLogging == 1 ) {
    t <- GetTime()
    FilePrint( gLogFile, "[" + t + "] " + logline )
  }
}

define Message( text, fatal ) {
  if( fatal ) {
    instr <- " (press space to quit)"
  } else {
    instr <- " (press space to continue)"
  }
  box <- MakeTextBox( text + instr, 
    gFont, .9*gVideoWidth, .9*gVideoHeight )
  AddObject( box, gWindow )
  Move( box, .05*gVideoWidth, .05*gVideoHeight )
  Draw()
  WaitForKeyDown(" ")
  RemoveObject( box, gWindow )
  Draw()
  MyLog( "Message: "+ text )
  if( fatal ) {
  MyLog( "Message: terminating" )
    SignalFatalError( "alex: " + text )
  }
}    

